<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>Gameplay &#8212; Flame</title>
  <!-- Stylesheets -->
  <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/basic.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/dart_domain.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/flutter_app.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/package.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/yarn_lexer.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/flames.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/copy-button.css" />
  <!-- Scripts -->
  <script src="../../_static/jquery.js"></script>
  <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
  <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
  <script src="../../_static/doctools.js"></script>
  <script src="../../_static/sphinx_highlight.js"></script>
  <script src="../../_static/flutter_app.js"></script>
  <script src="../../_static/clipboard.min.js"></script>
  <script src="../../_static/copybutton.js"></script>
  <script src="https://unpkg.com/mermaid@9.4.0/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true});</script>
  <script src="../../_static/versions.js"></script>
  <script src="../../_static/menu-expand.js"></script>
  <!--script src="searchindex.js" defer></script-->
  <!-- Links -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,400;0,700;1,400;1,700&display=swap">
  <link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../_static/fontawesome/fa-brands-400.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../_static/fontawesome/fa-solid-900.woff2">
  <link rel="stylesheet" href="../../_static/fontawesome/all.min.css">
  <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <link rel="index" title="Index" href="../../genindex.html" />
  <link rel="search" title="Search" href="../../search.html" />
  <link rel="next" title="To be continued" href="tbc.html" />
  <link rel="prev" title="Cards" href="step3.html" />
</head>

<body data-spy="scroll" data-target="#toc-local" data-offset="80">

<div class="top-bar">
  <button id="menu-button" class="btn" title="Toggle menu"><i class="fa fa-bars"></i></button>
  <script type="text/javascript">
    jQuery(function(){
      $("#menu-button").click(function() {
        $(this).toggleClass("active");
        $(".sidebar-left-area").toggleClass("active");
      });

      $('div.nav-left li > a:not(:only-child)').wrap('<div class=submenu></div>');
      $('div.nav-left div.submenu').prepend('<a class=arrow>&nbsp;</a>');
      $('div.nav-left div.submenu > a.arrow')
        .click(function() {
          $(this.parentElement.parentElement).toggleClass('current');
        });

      // This function ensures that when navigating to internal targets within the page (such as
      // a section header), those targets will be visible to the user and not obscured by the menu
      // bar at the top of the page.
      function scrollToHashTarget() {
        if (location.hash !== location.oldHash) {
          window.scrollBy(0, -60);
          location.oldHash = location.hash;
        }
      }
      window.location.oldHash = '';
      window.addEventListener('hashchange', scrollToHashTarget);
      scrollToHashTarget();
    });
  </script>

  <a href="../../index.html" class="logo_image">
    <img src="../../_static/logo_flame.png">
  </a>  
  <div class="highlight-box" role="alert" style="display:none">
    <div>
      <div class="title">highlighted:</div>
      <div class="content" id="highlight-content"></div>
    </div>
    <button type="button" class="close" data-dismiss="alert" aria-label="Dismiss">×</button>
  </div>
  <div class="expander"></div>

  <div class="versions-placeholder"></div>
  <a href="https://discord.com/invite/pxrBmy4" id="discord-button" class="btn"
     title="Blue Fire Discord server">
    <i class="fab fa-discord"></i>
  </a>
  <a href="https://github.com/flame-engine/flame/" id="github-button" class="btn"
     title="GitHub repository">
    <i class="fab fa-github"></i>
  </a>
</div>

<div class="sidebar-left-area">
  <div class="sidebar-left-bg"></div>
  <div class="sidebar-left">
    <div class="searchbox" role="search">
      <form id="search-form" action="../../search.html" method="get">
        <i class="icon fa fa-search"></i>
        <input type="search" class="form-control" id="search-input" name="q"
               placeholder="Search the docs..." autocomplete="off" />
      </form>
    </div>
    <div class="nav-left" role="navigation" aria-label="Main">
      <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../flame/flame.html">Flame</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../flame/structure.html">File Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/game_widget.html">Game Widget</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/game.html">Game Loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/components.html">Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/router.html">Router</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/platforms.html">Platforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/collision_detection.html">Collision Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/effects.html">Effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/camera_and_viewport.html">Camera &amp; Viewport</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/camera_component.html">Camera Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/inputs/inputs.html">Inputs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../flame/inputs/drag_events.html">Drag Events</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/inputs/gesture_input.html">Gesture Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/inputs/keyboard_input.html">Keyboard Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/inputs/other_inputs.html">Other Inputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/inputs/tap_events.html">Tap Events</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/rendering/rendering.html">Rendering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../flame/rendering/palette.html">Colors and Palette</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/rendering/decorators.html">Decorators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/rendering/images.html">Images, Sprites and Animations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/rendering/layers.html">Layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/rendering/particles.html">Particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/rendering/text_rendering.html">Text Rendering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../flame/other/other.html">Other</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../flame/other/debug.html">Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/other/util.html">Utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../flame/other/widgets.html">Widgets</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../bridge_packages/bridge_packages.html">Bridge Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_audio/flame_audio.html">flame_audio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_audio/audio.html">General audio</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_audio/bgm.html">Background music</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_audio/audio_pool.html">AudioPool</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_bloc/flame_bloc.html">flame_bloc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_bloc/bloc.html">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_bloc/bloc_components.html">Components</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_fire_atlas/flame_fire_atlas.html">flame_fire_atlas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_fire_atlas/fire_atlas.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_forge2d/flame_forge2d.html">flame_forge2d</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_forge2d/forge2d.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_isolate/flame_isolate.html">flame_isolate</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_isolate/isolate.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_oxygen/flame_oxygen.html">flame_oxygen</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_rive/flame_rive.html">flame_rive</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_rive/rive.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_splash_screen/flame_splash_screen.html">flame_splash_screen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_svg/flame_svg.html">flame_svg</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_svg/svg.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../bridge_packages/flame_tiled/flame_tiled.html">flame_tiled</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_tiled/tiled.html">Tiled</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../bridge_packages/flame_tiled/layers.html">Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../other_modules/other_modules.html">Other Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../other_modules/oxygen/oxygen.html">oxygen</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../other_modules/oxygen/components.html">Components</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../tutorials.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bare_flame_game.html">Bare Flame game</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="klondike.html">Klondike</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="step1.html">1. Preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="step2.html">2. Scaffolding</a></li>
<li class="toctree-l3"><a class="reference internal" href="step3.html">3. Cards</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">4. Gameplay</a></li>
<li class="toctree-l3"><a class="reference internal" href="tbc.html">[To be continued]...</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platformer/platformer.html">Ember Quest</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platformer/step_1.html">1. Preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platformer/step_2.html">2. Start Coding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platformer/step_3.html">3. Building the World</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platformer/step_4.html">4. Adding the Remaining Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platformer/step_5.html">5. Controlling Movement</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platformer/step_6.html">6. Adding the HUD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platformer/step_7.html">7. Adding Menus</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../space_shooter/space_shooter.html">Space Shooter</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../space_shooter/step_1.html">1. Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="../space_shooter/step_2.html">2. Controlling the player and adding some graphics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../development/development.html">Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../development/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../development/documentation.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../development/style_guide.html">Style Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../development/testing_guide.html">Tests Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../resources/resources.html">Resources</a><ul>
<li class="toctree-l2"><a class="reference external" href="https://pub.dev/documentation/flame/1.5.0/">Flame API</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.flame-engine.org/#/">Flame Examples</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
</div>

<div class="main-area">
  <div class="document-wrapper">
    <div class="warning hidden" id="version-warning">
      <p><strong>Warning:</strong> you are currently viewing the docs for an older
      version <span class="version"></span> of Flame.</p>
      <p>Please <a href="/">click here</a> to go see the documentation for the latest
      released version.</p>
    </div>
    <div class="document" role="main">
      
  <section class="tex2jax_ignore mathjax_ignore" id="gameplay">
<h1>Gameplay<a class="headerlink" href="#gameplay" title="Permalink to this heading">¶</a></h1>
<p>In this chapter we will be implementing the core of Klondike’s gameplay: how the cards move between
the stock and the waste, the piles and the foundations.</p>
<p>Before we begin though, let’s clean up all those cards that we left scattered across the table in
the previous chapter. Open the <code class="docutils literal notranslate"><span class="pre">KlondikeGame</span></code> class and erase the loop at the bottom of <code class="docutils literal notranslate"><span class="pre">onLoad()</span></code>
that was adding 28 cards onto the table.</p>
<section id="the-piles">
<h2>The piles<a class="headerlink" href="#the-piles" title="Permalink to this heading">¶</a></h2>
<p>Another small refactoring that we need to do is to rename our components: <code class="docutils literal notranslate"><span class="pre">Stock</span></code> ⇒ <code class="docutils literal notranslate"><span class="pre">StockPile</span></code>,
<code class="docutils literal notranslate"><span class="pre">Waste</span></code> ⇒ <code class="docutils literal notranslate"><span class="pre">WastePile</span></code>, <code class="docutils literal notranslate"><span class="pre">Foundation</span></code> ⇒ <code class="docutils literal notranslate"><span class="pre">FoundationPile</span></code>, and <code class="docutils literal notranslate"><span class="pre">Pile</span></code> ⇒ <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code>. This is
because these components have some common features in how they handle interactions with the cards,
and it would be convenient to have all of them implement a common API. We will call the interface
that they will all be implementing the <code class="docutils literal notranslate"><span class="pre">Pile</span></code> class.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Refactors and changes in architecture happen during development all the time:
it’s almost impossible to get the structure right on the first try. Do not be
anxious about changing code that you have written in the past: it is a good
habit to have.</p>
</div>
<p>After such a rename, we can begin implementing each of these components.</p>
<section id="stock-pile">
<h3>Stock pile<a class="headerlink" href="#stock-pile" title="Permalink to this heading">¶</a></h3>
<p>The <strong>stock</strong> is a place in the top-left corner of the playing field which holds the cards that are
not currently in play. We will need to build the following functionality for this component:</p>
<ol class="arabic simple">
<li><p>Ability to hold cards that are not currently in play, face down;</p></li>
<li><p>Tapping the stock should reveal top 3 cards and move them to the <strong>waste</strong> pile;</p></li>
<li><p>When the cards run out, there should be a visual indicating that this is the stock pile;</p></li>
<li><p>When the cards run out, tapping the empty stock should move all the cards from the waste pile
into the stock, turning them face down.</p></li>
</ol>
<p>The first question that needs to be decided here is this: who is going to own the <code class="docutils literal notranslate"><span class="pre">Card</span></code> components?
Previously we have been adding them directly to the game field, but now wouldn’t it be better to
say that the cards belong to the <code class="docutils literal notranslate"><span class="pre">Stock</span></code> component, or to the waste, or piles, or foundations? While
this approach is tempting, I believe it would make our life more complicated as we need to move a
card from one place to another.</p>
<p>So, I decided to stick with my first approach: the <code class="docutils literal notranslate"><span class="pre">Card</span></code> components are owned directly by the
<code class="docutils literal notranslate"><span class="pre">KlondikeGame</span></code> itself, whereas the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code> and other piles are merely aware of which cards are
currently placed there.</p>
<p>Having this in mind, let’s start implementing the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code> component:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">StockPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">StockPile</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">position</span><span class="p">})</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">super</span><span class="p">(</span><span class="nl">size:</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardSize</span><span class="p">);</span>

<span class="w">  </span><span class="c1">/// Which cards are currently placed onto this pile. The first card in the</span>
<span class="w">  </span><span class="c1">/// list is at the bottom, the last card is on top.</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_cards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">acquireCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="o">!</span><span class="n">card</span><span class="p">.</span><span class="n">isFaceUp</span><span class="p">);</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">acquireCard()</span></code> method stores the provided card into the internal list <code class="docutils literal notranslate"><span class="pre">_cards</span></code>; it also
moves that card to the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code>’s position and adjusts the cards priority so that they are
displayed in the right order. However, this method does not mount the card as a child of the
<code class="docutils literal notranslate"><span class="pre">StockPile</span></code> component – it remains belonging to the top-level game.</p>
<p>Speaking of the game class, let’s open the <code class="docutils literal notranslate"><span class="pre">KlondikeGame</span></code> and add the following lines to create a
full deck of 52 cards and put them onto the stock pile (this should be added at the end of the
<code class="docutils literal notranslate"><span class="pre">onLoad</span></code> method):</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">final</span><span class="w"> </span><span class="n">cards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="m">13</span><span class="p">;</span><span class="w"> </span><span class="n">rank</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">4</span><span class="p">;</span><span class="w"> </span><span class="n">suit</span><span class="o">++</span><span class="p">)</span>
<span class="w">      </span><span class="n">Card</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">suit</span><span class="p">)</span>
<span class="p">];</span>
<span class="n">world</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">cards</span><span class="p">);</span>
<span class="n">cards</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">stock</span><span class="p">.</span><span class="n">acquireCard</span><span class="p">);</span>
</pre></div>
</div>
<p>This concludes the first step of our short plan at the beginning of this section. For the second
step, though, we need to have a waste pile – so let’s make a quick detour and implement the
<code class="docutils literal notranslate"><span class="pre">WastePile</span></code> class.</p>
</section>
<section id="waste-pile">
<h3>Waste pile<a class="headerlink" href="#waste-pile" title="Permalink to this heading">¶</a></h3>
<p>The <strong>waste</strong> is a pile next to the stock. During the course of the game we will be taking the cards
from the top of the stock pile and putting them into the waste. The functionality of this class is
quite simple: it holds a certain number of cards face up, fanning out the top 3.</p>
<p>Let’s start implementing the <code class="docutils literal notranslate"><span class="pre">WastePile</span></code> class same way as we did with the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code> class, only
now the cards are expected to be face up:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">WastePile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">WastePile</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">position</span><span class="p">})</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">super</span><span class="p">(</span><span class="nl">size:</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardSize</span><span class="p">);</span>

<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_cards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">acquireCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">card</span><span class="p">.</span><span class="n">isFaceUp</span><span class="p">);</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So far, this puts all cards into a single neat pile, whereas we wanted a fan-out of top three. So,
let’s add a dedicated method <code class="docutils literal notranslate"><span class="pre">_fanOutTopCards()</span></code> for this, which we will call at the end of each
<code class="docutils literal notranslate"><span class="pre">acquireCard()</span></code>:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">_fanOutTopCards</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">_cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">_cards</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">_fanOffset</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">_cards</span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">2</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">_fanOffset</span><span class="p">);</span>
<span class="w">      </span><span class="n">_cards</span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">addScaled</span><span class="p">(</span><span class="n">_fanOffset</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">_fanOffset</span></code> variable here helps determine the shift between cards in the fan, which I decided
to be about 20% of the card’s width:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="n">_fanOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardWidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.2</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Now that the waste pile is ready, let’s get back to the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code>.</p>
</section>
<section id="stock-pile-tap-to-deal-cards">
<h3>Stock pile – tap to deal cards<a class="headerlink" href="#stock-pile-tap-to-deal-cards" title="Permalink to this heading">¶</a></h3>
<p>The second item on our todo list is the first interactive functionality in the game: tap the stock
pile to deal 3 cards onto the waste.</p>
<p>Adding tap functionality to the components in Flame is quite simple: first, we add the mixin
<code class="docutils literal notranslate"><span class="pre">HasTappableComponents</span></code> to our top-level game class:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">KlondikeGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasTappableComponents</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>And second, we add the mixin <code class="docutils literal notranslate"><span class="pre">TapCallbacks</span></code> to the component that we want to be tappable:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">StockPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">TapCallbacks</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>Oh, and we also need to say what we want to happen when the tap occurs. Here we want the top 3 cards
to be turned face up and moved to the waste pile. So, add the following method to the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code>
class:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onTapUp</span><span class="p">(</span><span class="n">TapUpEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">wastePile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="o">!</span><span class="p">.</span><span class="n">firstChild</span><span class="o">&lt;</span><span class="n">WastePile</span><span class="o">&gt;</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="n">card</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">removeLast</span><span class="p">();</span>
<span class="w">        </span><span class="n">card</span><span class="p">.</span><span class="n">flip</span><span class="p">();</span>
<span class="w">        </span><span class="n">wastePile</span><span class="p">.</span><span class="n">acquireCard</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>You have probably noticed that the cards move from one pile to another immediately, which looks very
unnatural. However, this is how it is going to be for now – we will defer making the game more
smooth till the next chapter of the tutorial.</p>
<p>Also, the cards are organized in a well-defined order right now, starting from Kings and ending with
Aces. This doesn’t make a very exciting gameplay though, so add line</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">cards</span><span class="p">.</span><span class="n">shuffle</span><span class="p">();</span>
</pre></div>
</div>
<p>in the <code class="docutils literal notranslate"><span class="pre">KlondikeGame</span></code> class right after the list of cards is created.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>For more information about tap functionality, see <a class="reference internal" href="#../../flame/inputs/tap-events.md"><code class="xref myst docutils literal notranslate"><span class="pre">../../flame/inputs/tap-events.md</span></code></a>.</p>
</div>
</section>
<section id="stock-pile-visual-representation">
<h3>Stock pile – visual representation<a class="headerlink" href="#stock-pile-visual-representation" title="Permalink to this heading">¶</a></h3>
<p>Currently, when the stock pile has no cards, it simply shows an empty space – there is no visual
cue that this is where the stock is. Such cue is needed, though, because we want the user to be
able to click the stock pile when it is empty in order to move all the cards from the waste back to
the stock so that they can be dealt again.</p>
<p>In our case, the empty stock pile will have a card-like border, and a circle in the middle:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">render</span><span class="p">(</span><span class="n">Canvas</span><span class="w"> </span><span class="n">canvas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">canvas</span><span class="p">.</span><span class="n">drawRRect</span><span class="p">(</span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardRRect</span><span class="p">,</span><span class="w"> </span><span class="n">_borderPaint</span><span class="p">);</span>
<span class="w">    </span><span class="n">canvas</span><span class="p">.</span><span class="n">drawCircle</span><span class="p">(</span>
<span class="w">      </span><span class="n">Offset</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">),</span>
<span class="w">      </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardWidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.3</span><span class="p">,</span>
<span class="w">      </span><span class="n">_circlePaint</span><span class="p">,</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>where the paints are defined as</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">_borderPaint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()</span>
<span class="w">    </span><span class="p">..</span><span class="n">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span>
<span class="w">    </span><span class="p">..</span><span class="n">strokeWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span>
<span class="w">    </span><span class="p">..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0xFF3F5B5D</span><span class="p">);</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">_circlePaint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()</span>
<span class="w">    </span><span class="p">..</span><span class="n">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span>
<span class="w">    </span><span class="p">..</span><span class="n">strokeWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span>
<span class="w">    </span><span class="p">..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0x883F5B5D</span><span class="p">);</span>
</pre></div>
</div>
<p>and the <code class="docutils literal notranslate"><span class="pre">cardRRect</span></code> in the <code class="docutils literal notranslate"><span class="pre">KlondikeGame</span></code> class as</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">cardRRect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RRect</span><span class="p">.</span><span class="n">fromRectAndRadius</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="p">.</span><span class="n">fromLTWH</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">cardWidth</span><span class="p">,</span><span class="w"> </span><span class="n">cardHeight</span><span class="p">),</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Radius</span><span class="p">.</span><span class="n">circular</span><span class="p">(</span><span class="n">cardRadius</span><span class="p">),</span>
<span class="w">  </span><span class="p">);</span>
</pre></div>
</div>
<p>Now when you click through the stock pile till the end, you should be able to see the placeholder
for the stock cards.</p>
</section>
<section id="stock-pile-refill-from-the-waste">
<h3>Stock pile – refill from the waste<a class="headerlink" href="#stock-pile-refill-from-the-waste" title="Permalink to this heading">¶</a></h3>
<p>The last piece of functionality to add, is to move the cards back from the waste pile into the stock
pile when the user taps on an empty stock. To implement this, we will modify the <code class="docutils literal notranslate"><span class="pre">onTapUp()</span></code> method
like so:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onTapUp</span><span class="p">(</span><span class="n">TapUpEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">wastePile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="o">!</span><span class="p">.</span><span class="n">firstChild</span><span class="o">&lt;</span><span class="n">WastePile</span><span class="o">&gt;</span><span class="p">()</span><span class="o">!</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">wastePile</span><span class="p">.</span><span class="n">removeAllCards</span><span class="p">().</span><span class="n">reversed</span><span class="p">.</span><span class="n">forEach</span><span class="p">((</span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">card</span><span class="p">.</span><span class="n">flip</span><span class="p">();</span>
<span class="w">        </span><span class="n">acquireCard</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">      </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="kd">final</span><span class="w"> </span><span class="n">card</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">removeLast</span><span class="p">();</span>
<span class="w">          </span><span class="n">card</span><span class="p">.</span><span class="n">flip</span><span class="p">();</span>
<span class="w">          </span><span class="n">wastePile</span><span class="p">.</span><span class="n">acquireCard</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>If you’re curious why we needed to reverse the list of cards removed from the waste pile, then it is
because we want to simulate the entire waste pile being turned over at once, and not each card being
flipped one by one in their places. You can check that this is working as intended by verifying that
on each subsequent run through the stock pile, the cards are dealt in the same order as they were
dealt in the first run.</p>
<p>The method <code class="docutils literal notranslate"><span class="pre">WastePile.removeAllCards()</span></code> still needs to be implemented though:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="n">removeAllCards</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">cards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">toList</span><span class="p">();</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cards</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>This pretty much concludes the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code> functionality, and we already implemented the <code class="docutils literal notranslate"><span class="pre">WastePile</span></code>
– so the only two components remaining are the <code class="docutils literal notranslate"><span class="pre">FoundationPile</span></code> and the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code>. We’ll start
with the first one because it looks simpler.</p>
</section>
<section id="foundation-piles">
<h3>Foundation piles<a class="headerlink" href="#foundation-piles" title="Permalink to this heading">¶</a></h3>
<p>The <strong>foundation</strong> piles are the four piles in the top right corner of the game. This is where we
will be building the ordered runs of cards from Ace to King. The functionality of this class is
similar to the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code> and the <code class="docutils literal notranslate"><span class="pre">WastePile</span></code>: it has to be able to hold cards face up, and there
has to be some visual to show where the foundation is when there are no cards there.</p>
<p>First, let’s implement the card-holding logic:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">FoundationPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FoundationPile</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">position</span><span class="p">})</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">super</span><span class="p">(</span><span class="nl">size:</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardSize</span><span class="p">);</span>

<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_cards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">acquireCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">card</span><span class="p">.</span><span class="n">isFaceUp</span><span class="p">);</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For visual representation of a foundation, I’ve decided to make a large icon of that foundation’s
suit, in grey color. Which means we’d need to update the definition of the class to include the
suit information:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">FoundationPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FoundationPile</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">intSuit</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="k">super</span><span class="p">.</span><span class="n">position</span><span class="p">})</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Suit</span><span class="p">.</span><span class="n">fromInt</span><span class="p">(</span><span class="n">intSuit</span><span class="p">),</span>
<span class="w">        </span><span class="k">super</span><span class="p">(</span><span class="nl">size:</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardSize</span><span class="p">);</span>

<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">Suit</span><span class="w"> </span><span class="n">suit</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code in the <code class="docutils literal notranslate"><span class="pre">KlondikeGame</span></code> class that generates the foundations will have to be adjusted
accordingly in order to pass the suit index to each foundation.</p>
<p>Now, the rendering code for the foundation pile will look like this:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">render</span><span class="p">(</span><span class="n">Canvas</span><span class="w"> </span><span class="n">canvas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">canvas</span><span class="p">.</span><span class="n">drawRRect</span><span class="p">(</span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardRRect</span><span class="p">,</span><span class="w"> </span><span class="n">_borderPaint</span><span class="p">);</span>
<span class="w">    </span><span class="n">suit</span><span class="p">.</span><span class="n">sprite</span><span class="p">.</span><span class="n">render</span><span class="p">(</span>
<span class="w">      </span><span class="n">canvas</span><span class="p">,</span>
<span class="w">      </span><span class="nl">position:</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">,</span>
<span class="w">      </span><span class="nl">anchor:</span><span class="w"> </span><span class="n">Anchor</span><span class="p">.</span><span class="n">center</span><span class="p">,</span>
<span class="w">      </span><span class="nl">size:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardWidth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.6</span><span class="p">),</span>
<span class="w">      </span><span class="nl">overridePaint:</span><span class="w"> </span><span class="n">_suitPaint</span><span class="p">,</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Here we need to have two paint objects, one for the border and one for the suits:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">_borderPaint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()</span>
<span class="w">    </span><span class="p">..</span><span class="n">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span>
<span class="w">    </span><span class="p">..</span><span class="n">strokeWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span>
<span class="w">    </span><span class="p">..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0x50ffffff</span><span class="p">);</span>
<span class="w">  </span><span class="kd">late</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">_suitPaint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()</span>
<span class="w">    </span><span class="p">..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">suit</span><span class="p">.</span><span class="n">isRed</span><span class="o">?</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0x3a000000</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0x64000000</span><span class="p">)</span>
<span class="w">    </span><span class="p">..</span><span class="n">blendMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlendMode</span><span class="p">.</span><span class="n">luminosity</span><span class="p">;</span>
</pre></div>
</div>
<p>The suit paint uses <code class="docutils literal notranslate"><span class="pre">BlendMode.luminosity</span></code> in order to convert the regular yellow/blue colors of
the suit sprites into grayscale. The “color” of the paint is different depending whether the suit
is red or black because the original luminosity of those sprites is different. Therefore, I had to
pick two different colors in order to make them look the same in grayscale.</p>
</section>
<section id="tableau-piles">
<h3>Tableau Piles<a class="headerlink" href="#tableau-piles" title="Permalink to this heading">¶</a></h3>
<p>The last piece of the game to be implemented is the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> component. There are seven of
these piles in total, and they are where the majority of the game play is happening.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> also needs a visual representation, in order to indicate that it’s a place where
a King can be placed when it is empty. I believe it could be just an empty frame, and that should
be sufficient:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">TableauPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">TableauPile</span><span class="p">({</span><span class="k">super</span><span class="p">.</span><span class="n">position</span><span class="p">})</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">super</span><span class="p">(</span><span class="nl">size:</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardSize</span><span class="p">);</span>

<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">_borderPaint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()</span>
<span class="w">    </span><span class="p">..</span><span class="n">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span>
<span class="w">    </span><span class="p">..</span><span class="n">strokeWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span>
<span class="w">    </span><span class="p">..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mh">0x50ffffff</span><span class="p">);</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">render</span><span class="p">(</span><span class="n">Canvas</span><span class="w"> </span><span class="n">canvas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">canvas</span><span class="p">.</span><span class="n">drawRRect</span><span class="p">(</span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardRRect</span><span class="p">,</span><span class="w"> </span><span class="n">_borderPaint</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Oh, and the class will need to be able hold the cards too, obviously. Here, some of the cards will
be face down, while others will be face up. Also we will need a small amount of vertical fanning,
similar to how we did it for the <code class="docutils literal notranslate"><span class="pre">WastePile</span></code> component:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">/// Which cards are currently placed onto this pile.</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_cards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="n">_fanOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardHeight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.05</span><span class="p">);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">acquireCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_fanOffset</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>All that remains now is to head over to the <code class="docutils literal notranslate"><span class="pre">KlondikeGame</span></code> and make sure that the cards are dealt
into the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code>s at the beginning of the game. Modify the code at the end of the <code class="docutils literal notranslate"><span class="pre">onLoad()</span></code>
method so that it looks like this:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">cards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">rank</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="m">13</span><span class="p">;</span><span class="w"> </span><span class="n">rank</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">4</span><span class="p">;</span><span class="w"> </span><span class="n">suit</span><span class="o">++</span><span class="p">)</span>
<span class="w">          </span><span class="n">Card</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span><span class="w"> </span><span class="n">suit</span><span class="p">)</span>
<span class="w">    </span><span class="p">];</span>
<span class="w">    </span><span class="n">cards</span><span class="p">.</span><span class="n">shuffle</span><span class="p">();</span>
<span class="w">    </span><span class="n">world</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">cards</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">7</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">7</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">piles</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">acquireCard</span><span class="p">(</span><span class="n">cards</span><span class="p">.</span><span class="n">removeLast</span><span class="p">());</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">piles</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flipTopCard</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">cards</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">stock</span><span class="p">.</span><span class="n">acquireCard</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Note how we remove the cards from the deck and place them into <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code>s one by one, and only
after that we put the remaining cards into the stock. Also, the <code class="docutils literal notranslate"><span class="pre">flipTopCard</span></code> method in the
<code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> class is as trivial as it sounds:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">flipTopCard</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">isFaceDown</span><span class="p">);</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">flip</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>If you run the game at this point, it would be nicely set up and look as if it was ready to play.
Except that we can’t move the cards yet, which is kinda a deal-breaker here. So without further ado,
presenting you the next section:</p>
</section>
</section>
<section id="moving-the-cards">
<h2>Moving the cards<a class="headerlink" href="#moving-the-cards" title="Permalink to this heading">¶</a></h2>
<p>Moving the cards is a somewhat more complicated topic than what we have had so far. We will split
it into several smaller steps:</p>
<ol class="arabic simple">
<li><p>Simple movement: grab a card and move it around.</p></li>
<li><p>Ensure that the user can only move the cards that they are allowed to.</p></li>
<li><p>Check that the cards are dropped at proper destinations.</p></li>
<li><p>Drag a run of cards.</p></li>
</ol>
<section id="simple-movement">
<h3>1. Simple movement<a class="headerlink" href="#simple-movement" title="Permalink to this heading">¶</a></h3>
<p>So, we want to be able to drag the cards on the screen. This is almost as simple as making the
<code class="docutils literal notranslate"><span class="pre">StockPile</span></code> tappable: first, we add the <code class="docutils literal notranslate"><span class="pre">HasDraggableComponents</span></code> mixin to our game class:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">KlondikeGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span>
<span class="w">    </span><span class="kd">with</span><span class="w"> </span><span class="n">HasTappableComponents</span><span class="p">,</span><span class="w"> </span><span class="n">HasDraggableComponents</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, head over into the <code class="docutils literal notranslate"><span class="pre">Card</span></code> class and add the <code class="docutils literal notranslate"><span class="pre">DragCallbacks</span></code> mixin:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">Card</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">DragCallbacks</span><span class="w"> </span><span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The next step is to implement the actual drag event callbacks: <code class="docutils literal notranslate"><span class="pre">onDragStart</span></code>, <code class="docutils literal notranslate"><span class="pre">onDragUpdate</span></code>, and
<code class="docutils literal notranslate"><span class="pre">onDragEnd</span></code>.</p>
<p>When the drag gesture is initiated, the first thing that we need to do is to raise the priority of
the card, so that it is rendered above all others. Without this, the card would be occasionally
“sliding beneath” other cards, which would look most unnatural:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragStart</span><span class="p">(</span><span class="n">DragStartEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>During the drag, the <code class="docutils literal notranslate"><span class="pre">onDragUpdate</span></code> event will be called continuously. Using this callback we will
be updating the position of the card so that it follows the movement of the finger (or the mouse).
The <code class="docutils literal notranslate"><span class="pre">event</span></code> object passed to this callback contains the most recent coordinate of the point of
touch, and also the <code class="docutils literal notranslate"><span class="pre">delta</span></code> property – which is the displacement vector since the previous call of
<code class="docutils literal notranslate"><span class="pre">onDragUpdate</span></code>. The only problem is that this delta is measured in screen pixels, whereas we want
it to be in game world units. The conversion between the two is given by the camera zoom level, so
we will add an extra method to determine the zoom level:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragUpdate</span><span class="p">(</span><span class="n">DragUpdateEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">cameraZoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">findGame</span><span class="p">()</span><span class="o">!</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FlameGame</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">firstChild</span><span class="o">&lt;</span><span class="n">CameraComponent</span><span class="o">&gt;</span><span class="p">()</span><span class="o">!</span>
<span class="w">        </span><span class="p">.</span><span class="n">viewfinder</span>
<span class="w">        </span><span class="p">.</span><span class="n">zoom</span><span class="p">;</span>
<span class="w">    </span><span class="n">position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">delta</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cameraZoom</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>So far this allows you to grab any card and drag it anywhere around the table. What we want,
however, is to be able to restrict where the card is allowed or not allowed to go. This is where
the core of the logic of the game begins.</p>
</section>
<section id="move-only-allowed-cards">
<h3>2. Move only allowed cards<a class="headerlink" href="#move-only-allowed-cards" title="Permalink to this heading">¶</a></h3>
<p>The first restriction that we impose is that the user should only be able to drag the cards that we
allow, which include: (1) the top card of a waste pile, (2) the top card of a foundation pile, and
(3) any face-up card in a tableau pile.</p>
<p>Thus, in order to determine whether a card can be moved or not, we need to know which pile it
currently belongs to. There could be several ways that we go about it, but seemingly the most
straightforward is to let every card keep a reference to the pile in which it currently resides.</p>
<p>So, let’s start by defining the abstract interface <code class="docutils literal notranslate"><span class="pre">Pile</span></code> that all our existing piles will be
implementing:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nc">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We will expand this class further later, but for now let’s make sure that each of the classes
<code class="docutils literal notranslate"><span class="pre">StockPile</span></code>, <code class="docutils literal notranslate"><span class="pre">WastePile</span></code>, <code class="docutils literal notranslate"><span class="pre">FoundationPile</span></code>, and <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> are marked as implementing this
interface:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">StockPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">TapCallbacks</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">WastePile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">card</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">FoundationPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">card</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">TableauPile</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">card</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also wanted to let every <code class="docutils literal notranslate"><span class="pre">Card</span></code> know which pile it is currently in. For this, add the field
<code class="docutils literal notranslate"><span class="pre">Pile?</span> <span class="pre">pile</span></code> into the <code class="docutils literal notranslate"><span class="pre">Card</span></code> class, and make sure to set it in each pile’s <code class="docutils literal notranslate"><span class="pre">acquireCard()</span></code> method,
like so:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">acquireCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">pile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Now we can put this new functionality to use: go into the <code class="docutils literal notranslate"><span class="pre">Card.onDragStart()</span></code> method and modify
it so that it would check whether the card is allowed to be moved before starting the drag:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragStart</span><span class="p">(</span><span class="n">DragStartEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pile</span><span class="o">?</span><span class="p">.</span><span class="n">canMoveCard</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="o">??</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">_isDragging</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">      </span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>We have also added the boolean <code class="docutils literal notranslate"><span class="pre">_isDragging</span></code> variable here: make sure to define it, and then to
check this flag in the <code class="docutils literal notranslate"><span class="pre">onDragUpdate()</span></code> method, and to set it back to false in the <code class="docutils literal notranslate"><span class="pre">onDragEnd()</span></code>:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragUpdate</span><span class="p">(</span><span class="n">DragUpdateEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">_isDragging</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">cameraZoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">findGame</span><span class="p">()</span><span class="o">!</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FlameGame</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">firstChild</span><span class="o">&lt;</span><span class="n">CameraComponent</span><span class="o">&gt;</span><span class="p">()</span><span class="o">!</span>
<span class="w">        </span><span class="p">.</span><span class="n">viewfinder</span>
<span class="w">        </span><span class="p">.</span><span class="n">zoom</span><span class="p">;</span>
<span class="w">    </span><span class="n">position</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">delta</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cameraZoom</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragEnd</span><span class="p">(</span><span class="n">DragEndEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_isDragging</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Now the only the proper cards can be dragged, but they still drop at random positions on the table,
so let’s work on that.</p>
</section>
<section id="dropping-the-cards-at-proper-locations">
<h3>3. Dropping the cards at proper locations<a class="headerlink" href="#dropping-the-cards-at-proper-locations" title="Permalink to this heading">¶</a></h3>
<p>At this point what we want to do is to figure out where the dragged card is being dropped. More
specifically, we want to know into which <em>pile</em> it is being dropped. This can be achieved by using
the <code class="docutils literal notranslate"><span class="pre">componentsAtPoint()</span></code> API, which allows you to query which components are located at a given
position on the screen.</p>
<p>Thus, my first attempt at revising the <code class="docutils literal notranslate"><span class="pre">onDragEnd</span></code> callback looks like this:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragEnd</span><span class="p">(</span><span class="n">DragEndEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">_isDragging</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">_isDragging</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">dropPiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="o">!</span>
<span class="w">        </span><span class="p">.</span><span class="n">componentsAtPoint</span><span class="p">(</span><span class="n">position</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">whereType</span><span class="o">&lt;</span><span class="n">Pile</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">toList</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dropPiles</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// if (card is allowed to be dropped into this pile) {</span>
<span class="w">      </span><span class="c1">//   remove the card from the current pile</span>
<span class="w">      </span><span class="c1">//   add the card into the new pile</span>
<span class="w">      </span><span class="c1">// }</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// return the card to where it was originally</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>This still contains several placeholders for the functionality that still needs to be implemented,
so let’s get to it.</p>
<p>First piece of the puzzle is the “is card allowed to be dropped here?” check. To implement this,
first head over into the <code class="docutils literal notranslate"><span class="pre">Pile</span></code> class and add the <code class="docutils literal notranslate"><span class="pre">canAcceptCard()</span></code> abstract method:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nc">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canAcceptCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Obviously this now needs to be implemented for every <code class="docutils literal notranslate"><span class="pre">Pile</span></code> subclass, so let’s get to it:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">FoundationPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canAcceptCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">topCardRank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">isEmpty</span><span class="o">?</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">rank</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">rank</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">topCardRank</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">TableauPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canAcceptCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">rank</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">13</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">final</span><span class="w"> </span><span class="n">topCard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">;</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">suit</span><span class="p">.</span><span class="n">isRed</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">!</span><span class="n">topCard</span><span class="p">.</span><span class="n">suit</span><span class="p">.</span><span class="n">isRed</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">          </span><span class="n">card</span><span class="p">.</span><span class="n">rank</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">topCard</span><span class="p">.</span><span class="n">rank</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(for the <code class="docutils literal notranslate"><span class="pre">StockPile</span></code> and the <code class="docutils literal notranslate"><span class="pre">WastePile</span></code> the method should just return false, since no cards should
be dropped there).</p>
<p>Alright, next part is the “remove the card from its current pile”. Once again, let’s head over to
the <code class="docutils literal notranslate"><span class="pre">Pile</span></code> class and add the <code class="docutils literal notranslate"><span class="pre">removeCard()</span></code> abstract method:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nc">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">removeCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then we need to re-visit all four pile subclasses and implement this method:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">StockPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">removeCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">StateError</span><span class="p">(</span><span class="s1">&#39;cannot remove cards from here&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">WastePile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">removeCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">card</span><span class="p">));</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">removeLast</span><span class="p">();</span>
<span class="w">    </span><span class="n">_fanOutTopCards</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">FoundationPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">removeCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">card</span><span class="p">));</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">removeLast</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">TableauPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">removeCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">isFaceUp</span><span class="p">);</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">.</span><span class="n">removeRange</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">isFaceDown</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">flipTopCard</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The next action in our pseudo-code is to “add the card to the new pile”. But this one we have
already implemented: it’s the <code class="docutils literal notranslate"><span class="pre">acquireCard()</span></code> method. So all we need is to declare it in the <code class="docutils literal notranslate"><span class="pre">Pile</span></code>
interface:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">abstract</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nc">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">acquireCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last piece that’s missing is “return the card to where it was”. You can probably guess how we
are going to go about this one: add the <code class="docutils literal notranslate"><span class="pre">returnCard()</span></code> method into the <code class="docutils literal notranslate"><span class="pre">Pile</span></code> interface, and then
implement this method in all four pile subclasses:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">StockPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">returnCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">StateError</span><span class="p">(</span><span class="s1">&#39;cannot remove cards from here&#39;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">WastePile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">returnCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">    </span><span class="n">_fanOutTopCards</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">FoundationPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">returnCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">TableauPile</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Pile</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">returnCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_cards</span><span class="p">[</span><span class="n">index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">].</span><span class="n">position</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_fanOffset</span><span class="p">;</span>
<span class="w">    </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, putting this all together, the <code class="docutils literal notranslate"><span class="pre">Card</span></code>’s <code class="docutils literal notranslate"><span class="pre">onDragEnd</span></code> method will look like this:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragEnd</span><span class="p">(</span><span class="n">DragEndEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">_isDragging</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">_isDragging</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">dropPiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="o">!</span>
<span class="w">        </span><span class="p">.</span><span class="n">componentsAtPoint</span><span class="p">(</span><span class="n">position</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">whereType</span><span class="o">&lt;</span><span class="n">Pile</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">toList</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dropPiles</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dropPiles</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">canAcceptCard</span><span class="p">(</span><span class="k">this</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pile</span><span class="o">!</span><span class="p">.</span><span class="n">removeCard</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="n">dropPiles</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">acquireCard</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">pile</span><span class="o">!</span><span class="p">.</span><span class="n">returnCard</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Ok, that was quite a lot of work – but if you run the game now, you’d be able to move the cards
properly from one pile to another, and they will never go where they are not supposed to go. The
only thing that remains is to be able to move multiple cards at once between tableau piles. So take
a short break, and then on to the next section!</p>
</section>
<section id="moving-a-run-of-cards">
<h3>4. Moving a run of cards<a class="headerlink" href="#moving-a-run-of-cards" title="Permalink to this heading">¶</a></h3>
<p>In this section we will be implementing the necessary changes to allow us to move small stacks of
cards between the tableau piles. Before we begin, though, we need to make a small fix first.</p>
<p>You have probably noticed when running the game in the previous section that the cards in the
tableau piles clamp too closely together. That is, they are at the correct distance when they face
down, but they should be at a larger distance when they face up, which is not currently the case.
This makes it really difficult to see which cards are available for dragging.</p>
<p>So, let’s head over into the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> class and create a new method <code class="docutils literal notranslate"><span class="pre">layOutCards()</span></code>, whose job
would be to ensure that all cards currently in the pile have the right positions:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="n">_fanOffset1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardHeight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.05</span><span class="p">);</span>
<span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="n">_fanOffset2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardHeight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">0.20</span><span class="p">);</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">layOutCards</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_cards</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">_cards</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">position</span><span class="p">.</span><span class="n">setFrom</span><span class="p">(</span><span class="n">position</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">_cards</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span>
<span class="w">        </span><span class="p">..</span><span class="n">setFrom</span><span class="p">(</span><span class="n">_cards</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">].</span><span class="n">position</span><span class="p">)</span>
<span class="w">        </span><span class="p">..</span><span class="n">add</span><span class="p">(</span><span class="n">_cards</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">].</span><span class="n">isFaceDown</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">_fanOffset1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_fanOffset2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Make sure to call this method at the end of <code class="docutils literal notranslate"><span class="pre">removeCard()</span></code>, <code class="docutils literal notranslate"><span class="pre">returnCard()</span></code>, and <code class="docutils literal notranslate"><span class="pre">acquireCard()</span></code> –
replacing any current logic that handles card positioning.</p>
<p>Another problem that you may have noticed is that for taller card stacks it becomes hard to place a
card there. This is because our logic for determining in which pile the card is being dropped checks
whether the center of the card is inside any of the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> components – but those components
have only the size of a single card! To fix this inconsistency, all we need is to declare that the
height of the tableau pile is at least as tall as all the cards in it, or even higher. Add this line
at the end of the <code class="docutils literal notranslate"><span class="pre">layOutCards()</span></code> method:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KlondikeGame</span><span class="p">.</span><span class="n">cardHeight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">1.5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>The factor <code class="docutils literal notranslate"><span class="pre">1.5</span></code> here adds a little bit extra space at the bottom of each pile. You can temporarily
turn the debug mode on to see the hitboxes.</p>
<p>Ok, let’s get to our main topic: how to move a stack of cards at once.</p>
<p>First thing that we’re going to add is the list of <code class="docutils literal notranslate"><span class="pre">attachedCards</span></code> for every card. This list will
be non-empty only when the card is being dragged while having other cards on top. Add the following
declaration to the <code class="docutils literal notranslate"><span class="pre">Card</span></code> class:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="n">attachedCards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
</pre></div>
</div>
<p>Now, in order to create this list in <code class="docutils literal notranslate"><span class="pre">onDragStart</span></code>, we need to query the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> for the list
of cards that are on top of the given card. Let’s add such a method into the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> class:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cardsOnTop</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">assert</span><span class="p">(</span><span class="n">card</span><span class="p">.</span><span class="n">isFaceUp</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">card</span><span class="p">));</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">indexOf</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">getRange</span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">length</span><span class="p">).</span><span class="n">toList</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>While we are in the <code class="docutils literal notranslate"><span class="pre">TableauPile</span></code> class, let’s also update the <code class="docutils literal notranslate"><span class="pre">canMoveCard()</span></code> method to allow
dragging cards that are not necessarily on top:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canMoveCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">isFaceUp</span><span class="p">;</span>
</pre></div>
</div>
<p>Heading back into the <code class="docutils literal notranslate"><span class="pre">Card</span></code> class, we can use this method in order to populate the list of
<code class="docutils literal notranslate"><span class="pre">attachedCards</span></code> when the card starts to move:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragStart</span><span class="p">(</span><span class="n">DragStartEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pile</span><span class="o">?</span><span class="p">.</span><span class="n">canMoveCard</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="o">??</span><span class="w"> </span><span class="kc">false</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">_isDragging</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">      </span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">100</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pile</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">TableauPile</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">        </span><span class="kd">final</span><span class="w"> </span><span class="n">extraCards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pile</span><span class="o">!</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">TableauPile</span><span class="p">).</span><span class="n">cardsOnTop</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">card</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">extraCards</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">card</span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">101</span><span class="p">;</span>
<span class="w">          </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">card</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Now all we need to do is to make sure that the attached cards are also moved with the main card in
the <code class="docutils literal notranslate"><span class="pre">onDragUpdate</span></code> method:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragUpdate</span><span class="p">(</span><span class="n">DragUpdateEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">_isDragging</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">cameraZoom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">findGame</span><span class="p">()</span><span class="o">!</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">FlameGame</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">firstChild</span><span class="o">&lt;</span><span class="n">CameraComponent</span><span class="o">&gt;</span><span class="p">()</span><span class="o">!</span>
<span class="w">        </span><span class="p">.</span><span class="n">viewfinder</span>
<span class="w">        </span><span class="p">.</span><span class="n">zoom</span><span class="p">;</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event</span><span class="p">.</span><span class="n">delta</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">cameraZoom</span><span class="p">;</span>
<span class="w">    </span><span class="n">position</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
<span class="w">    </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">forEach</span><span class="p">((</span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">delta</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>This does the trick, almost. All that remains is to fix any loose ends. For example, we don’t want
to let the user drop a stack of cards onto a foundation pile, so let’s head over into the
<code class="docutils literal notranslate"><span class="pre">FoundationPile</span></code> class and modify the <code class="docutils literal notranslate"><span class="pre">canAcceptCard()</span></code> method accordingly:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">canAcceptCard</span><span class="p">(</span><span class="n">Card</span><span class="w"> </span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">topCardRank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">isEmpty</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">_cards</span><span class="p">.</span><span class="n">last</span><span class="p">.</span><span class="n">rank</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">card</span><span class="p">.</span><span class="n">suit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">suit</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">card</span><span class="p">.</span><span class="n">rank</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">topCardRank</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">card</span><span class="p">.</span><span class="n">attachedCards</span><span class="p">.</span><span class="n">isEmpty</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Secondly, we need to properly take care of the stack of card as it is being dropped into a tableau
pile. So, go back into the <code class="docutils literal notranslate"><span class="pre">Card</span></code> class and update its <code class="docutils literal notranslate"><span class="pre">onDragEnd()</span></code> method to also move the
attached cards into the pile, and the same when it comes to returning the cards into the old pile:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onDragEnd</span><span class="p">(</span><span class="n">DragEndEvent</span><span class="w"> </span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">_isDragging</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">_isDragging</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">dropPiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent</span><span class="o">!</span>
<span class="w">        </span><span class="p">.</span><span class="n">componentsAtPoint</span><span class="p">(</span><span class="n">position</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">whereType</span><span class="o">&lt;</span><span class="n">Pile</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">toList</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dropPiles</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dropPiles</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">canAcceptCard</span><span class="p">(</span><span class="k">this</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pile</span><span class="o">!</span><span class="p">.</span><span class="n">removeCard</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="n">dropPiles</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">acquireCard</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">attachedCards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">forEach</span><span class="p">((</span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">dropPiles</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">acquireCard</span><span class="p">(</span><span class="n">card</span><span class="p">));</span>
<span class="w">          </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">pile</span><span class="o">!</span><span class="p">.</span><span class="n">returnCard</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">attachedCards</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">forEach</span><span class="p">((</span><span class="n">card</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">pile</span><span class="o">!</span><span class="p">.</span><span class="n">returnCard</span><span class="p">(</span><span class="n">card</span><span class="p">));</span>
<span class="w">      </span><span class="n">attachedCards</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p>Well, this is it! The game is now fully playable. Press the button below to see what the resulting
code looks like, or to play it live. In the next section we will discuss how to make it more
animated with the help of effects.</p>
</section>
</section>
</section>


    </div>
    <div class="copyright">
      The content on this page is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 License</a>,
      and code samples under the <a href="https://raw.githubusercontent.com/flame-engine/flame/main/LICENSE">MIT License</a>.
    </div>
    <div class="prev-next-area">
      <a class="left-prev" id="prev-link" href="step3.html" title="previous page">
        <i class="fa fa-angle-left"></i>
        <div class="prev-next-info">
          <p class="prev-next-subtitle">Previous:</p>
          <p class="prev-next-title">Cards</p>
        </div>
      </a>
      <div class='expander'></div>
      <a class="right-next" id="next-link" href="tbc.html" title="next page">
        <div class="prev-next-info">
          <p class="prev-next-subtitle">Next:</p>
          <p class="prev-next-title">To be continued</p>
        </div>
        <i class="fa fa-angle-right"></i>
      </a>
    </div>
  </div>

  <div class="sidebar-right">
    
    <div class="nav-right" role="navigation" aria-label="table of contents">
      <div id='toc-local' class='list-group'>
 <div class='header'><i class='fa fa-list'></i> Contents</div>
  <a href='#the-piles' class='list-group-item level-1'>The piles</a>
  <a href='#stock-pile' class='list-group-item level-2'>Stock pile</a>
  <a href='#waste-pile' class='list-group-item level-2'>Waste pile</a>
  <a href='#stock-pile-tap-to-deal-cards' class='list-group-item level-2'>Stock pile – tap to deal cards</a>
  <a href='#stock-pile-visual-representation' class='list-group-item level-2'>Stock pile – visual representation</a>
  <a href='#stock-pile-refill-from-the-waste' class='list-group-item level-2'>Stock pile – refill from the waste</a>
  <a href='#foundation-piles' class='list-group-item level-2'>Foundation piles</a>
  <a href='#tableau-piles' class='list-group-item level-2'>Tableau Piles</a>
  <a href='#moving-the-cards' class='list-group-item level-1'>Moving the cards</a>
  <a href='#simple-movement' class='list-group-item level-2'>1. Simple movement</a>
  <a href='#move-only-allowed-cards' class='list-group-item level-2'>2. Move only allowed cards</a>
  <a href='#dropping-the-cards-at-proper-locations' class='list-group-item level-2'>3. Dropping the cards at proper locations</a>
  <a href='#moving-a-run-of-cards' class='list-group-item level-2'>4. Moving a run of cards</a>
</div>

    </div>
  </div>

  <div class="expander"></div>
</div>




</body>
</html>