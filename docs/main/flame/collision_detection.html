<!DOCTYPE html>
<html lang="en">
<head>
<meta name="robots" content="noindex">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>Collision Detection &#8212; Flame</title>
  <!-- Stylesheets -->
  <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b20cc3f5" />
  <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=eeb27264" />
  <link rel="stylesheet" type="text/css" href="../_static/dart_domain.css" />
  <link rel="stylesheet" type="text/css" href="../_static/flutter_app.css?v=6984c178" />
  <link rel="stylesheet" type="text/css" href="../_static/package.css?v=7889e545" />
  <link rel="stylesheet" type="text/css" href="../_static/yarn_lexer.css?v=932ca0ec" />
  <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
  <link rel="stylesheet" type="text/css" href="../_static/flames.css?v=ac7bdd72" />
  <link rel="stylesheet" type="text/css" href="../_static/copy-button.css?v=deecb4da" />
  <!-- Scripts -->
  <script src="../_static/jquery.js?v=5d32c60e"></script>
  <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
  <script src="../_static/documentation_options.js?v=5929fcd5"></script>
  <script src="../_static/doctools.js?v=0b60eaae"></script>
  <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
  <script src="../_static/flutter_app.js?v=3619378f"></script>
  <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
  <script src="../_static/copybutton.js?v=f281be69"></script>
  <script src="../_static/versions.js?v=58484017"></script>
  <script src="../_static/menu-expand.js?v=8e297497"></script>
  <!--script src="searchindex.js" defer></script-->
  <!-- Links -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,400;0,700;1,400;1,700&display=swap">
  <link rel="preload" as="font" type="font/woff2" crossorigin="" href="../_static/fontawesome/fa-brands-400.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin="" href="../_static/fontawesome/fa-solid-900.woff2">
  <link rel="stylesheet" href="../_static/fontawesome/all.min.css">
  <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <link rel="index" title="Index" href="../genindex.html" />
  <link rel="search" title="Search" href="../search.html" />
  <link rel="next" title="Effects" href="effects.html" />
  <link rel="prev" title="Supported Platforms" href="platforms.html" />
</head>

<body data-spy="scroll" data-target="#toc-local" data-offset="80">

<div class="top-bar">
  <button id="menu-button" class="btn" title="Toggle menu"><i class="fa fa-bars"></i></button>
  <script type="text/javascript">
    jQuery(function(){
      $("#menu-button").click(function() {
        $(this).toggleClass("active");
        $(".sidebar-left-area").toggleClass("active");
      });

      $('div.nav-left li > a:not(:only-child)').wrap('<div class=submenu></div>');
      $('div.nav-left div.submenu').prepend('<a class=arrow>&nbsp;</a>');
      $('div.nav-left div.submenu > a.arrow')
        .click(function() {
          $(this.parentElement.parentElement).toggleClass('current');
        });

      // This function ensures that when navigating to internal targets within the page (such as
      // a section header), those targets will be visible to the user and not obscured by the menu
      // bar at the top of the page.
      function scrollToHashTarget() {
        if (location.hash !== location.oldHash) {
          window.scrollBy(0, -60);
          location.oldHash = location.hash;
        }
      }
      window.location.oldHash = '';
      window.addEventListener('hashchange', scrollToHashTarget);
      scrollToHashTarget();
    });
  </script>

  <a href="../index.html" class="logo_image" aria-label="Navigate to home page">
    <img src="../_static/logo_flame.png" alt="Flame logo: a fiery symbol along with the FLAME wordmark.">
  </a>  
  <div class="highlight-box" role="alert" style="display:none">
    <div>
      <div class="title">highlighted:</div>
      <div class="content" id="highlight-content"></div>
    </div>
    <button type="button" class="close" data-dismiss="alert" aria-label="Dismiss">×</button>
  </div>
  <div class="expander"></div>

  <div class="versions-placeholder"></div>
  <a href="https://discord.com/invite/pxrBmy4" id="discord-button" class="btn"
     title="Blue Fire Discord server">
    <i class="fab fa-discord"></i>
  </a>
  <a href="https://github.com/flame-engine/flame/" id="github-button" class="btn"
     title="GitHub repository">
    <i class="fab fa-github"></i>
  </a>
</div>

<div class="sidebar-left-area">
  <div class="sidebar-left-bg"></div>
  <div class="sidebar-left">
    <div class="searchbox" role="search">
      <form id="search-form" action="../search.html" method="get">
        <i class="icon fa fa-search"></i>
        <input type="search" class="form-control" id="search-input" name="q"
               placeholder="Search the docs..." autocomplete="off" />
      </form>
    </div>
    <div class="nav-left" role="navigation" aria-label="Main">
      <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="flame.html">Flame</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="structure.html">File Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="game_widget.html">Game Widget</a></li>
<li class="toctree-l2"><a class="reference internal" href="game.html">Game Loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="components.html">Components</a></li>
<li class="toctree-l2"><a class="reference internal" href="router.html">Router</a></li>
<li class="toctree-l2"><a class="reference internal" href="platforms.html">Platforms</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Collision Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="effects.html">Effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="camera_component.html">Camera Component</a></li>
<li class="toctree-l2"><a class="reference internal" href="inputs/inputs.html">Inputs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="inputs/drag_events.html">Drag Events</a></li>
<li class="toctree-l3"><a class="reference internal" href="inputs/gesture_input.html">Gesture Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="inputs/keyboard_input.html">Keyboard Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="inputs/other_inputs.html">Other Inputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="inputs/tap_events.html">Tap Events</a></li>
<li class="toctree-l3"><a class="reference internal" href="inputs/pointer_events.html">Pointer Events</a></li>
<li class="toctree-l3"><a class="reference internal" href="inputs/hardware_keyboard_detector.html">HardwareKeyboardDetector</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="rendering/rendering.html">Rendering</a><ul>
<li class="toctree-l3"><a class="reference internal" href="rendering/palette.html">Colors and Palette</a></li>
<li class="toctree-l3"><a class="reference internal" href="rendering/decorators.html">Decorators</a></li>
<li class="toctree-l3"><a class="reference internal" href="rendering/images.html">Images, Sprites and Animations</a></li>
<li class="toctree-l3"><a class="reference internal" href="rendering/layers.html">Layers and Snapshots</a></li>
<li class="toctree-l3"><a class="reference internal" href="rendering/particles.html">Particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="rendering/text_rendering.html">Text Rendering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="layout/layout.html">Layout</a><ul>
<li class="toctree-l3"><a class="reference internal" href="layout/align_component.html">AlignComponent</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="overlays.html">Overlays</a></li>
<li class="toctree-l2"><a class="reference internal" href="other/other.html">Other</a><ul>
<li class="toctree-l3"><a class="reference internal" href="other/debug.html">Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="other/util.html">Utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="other/widgets.html">Widgets</a></li>
<li class="toctree-l3"><a class="reference internal" href="other/performance.html">Performance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bridge_packages/bridge_packages.html">Bridge Packages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_audio/flame_audio.html">flame_audio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_audio/audio.html">General audio</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_audio/bgm.html">Background music</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_audio/audio_pool.html">AudioPool</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_bloc/flame_bloc.html">flame_bloc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_bloc/bloc.html">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_bloc/bloc_components.html">Components</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_fire_atlas/flame_fire_atlas.html">flame_fire_atlas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_fire_atlas/fire_atlas.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_forge2d/flame_forge2d.html">flame_forge2d</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_forge2d/forge2d.html">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_forge2d/joints.html">Joints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_isolate/flame_isolate.html">flame_isolate</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_isolate/isolate.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_lottie/flame_lottie.html">flame_lottie</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_network_assets/flame_network_assets.html">flame_network_assets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_oxygen/flame_oxygen.html">flame_oxygen</a><ul class="simple">
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_rive/flame_rive.html">flame_rive</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_rive/rive.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_riverpod/flame_riverpod.html">flame_riverpod</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_riverpod/riverpod.html">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_riverpod/component.html">Component</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_riverpod/widget.html">Widget</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_splash_screen/flame_splash_screen.html">flame_splash_screen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_spine/flame_spine.html">flame_spine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_svg/flame_svg.html">flame_svg</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_svg/svg.html">Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../bridge_packages/flame_tiled/flame_tiled.html">flame_tiled</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_tiled/tiled.html">Tiled</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bridge_packages/flame_tiled/layers.html">Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../other_modules/other_modules.html">Other Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../other_modules/jenny/jenny.html">jenny</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../other_modules/jenny/language/language.html">YarnSpinner language</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/language/nodes.html">Nodes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/language/lines.html">Lines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/language/options.html">Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/language/commands/commands.html">Commands</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/character.html">&lt;&lt;character&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/declare.html">&lt;&lt;declare&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/if.html">&lt;&lt;if&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/jump.html">&lt;&lt;jump&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/local.html">&lt;&lt;local&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/set.html">&lt;&lt;set&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/stop.html">&lt;&lt;stop&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/visit.html">&lt;&lt;visit&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/wait.html">&lt;&lt;wait&gt;&gt;</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/commands/user_defined_commands.html">User-defined commands</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/language/expressions/expressions.html">Expressions</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/expressions/variables.html">Variables</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/expressions/operators.html">Operators</a></li>
<li class="toctree-l5"><a class="reference internal" href="../other_modules/jenny/language/expressions/functions/functions.html">Functions</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../other_modules/jenny/language/expressions/functions/random.html">Random functions</a></li>
<li class="toctree-l6"><a class="reference internal" href="../other_modules/jenny/language/expressions/functions/numeric.html">Numeric functions</a></li>
<li class="toctree-l6"><a class="reference internal" href="../other_modules/jenny/language/expressions/functions/type.html">Type conversion functions</a></li>
<li class="toctree-l6"><a class="reference internal" href="../other_modules/jenny/language/expressions/functions/misc.html">Miscellaneous functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/language/markup.html">Markup</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../other_modules/jenny/runtime/jenny_runtime.html">Jenny API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/character.html">Character</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/character_storage.html">CharacterStorage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/command_storage.html">CommandStorage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/dialogue_choice.html">DialogueChoice</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/dialogue_line.html">DialogueLine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/dialogue_option.html">DialogueOption</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/dialogue_runner.html">DialogueRunner</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/dialogue_view.html">DialogueView</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/function_storage.html">FunctionStorage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/markup_attribute.html">MarkupAttribute</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/node.html">Node</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/user_defined_command.html">UserDefinedCommand</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/variable_storage.html">VariableStorage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../other_modules/jenny/runtime/yarn_project.html">YarnProject</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../other_modules/oxygen/oxygen.html">oxygen</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../other_modules/oxygen/components.html">Components</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/bare_flame_game.html">Bare Flame game</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/klondike/klondike.html">Klondike</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/klondike/step1.html">1. Preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/klondike/step2.html">2. Scaffolding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/klondike/step3.html">3. Cards</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/klondike/step4.html">4. Gameplay</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/klondike/step5.html">5. Additional features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/platformer/platformer.html">Ember Quest</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/platformer/step_1.html">1. Preparation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/platformer/step_2.html">2. Start Coding</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/platformer/step_3.html">3. Building the World</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/platformer/step_4.html">4. Adding the Remaining Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/platformer/step_5.html">5. Controlling Movement</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/platformer/step_6.html">6. Adding the HUD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/platformer/step_7.html">7. Adding Menus</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/space_shooter/space_shooter.html">Space Shooter</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/space_shooter/step_1.html">1. Getting Started</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/space_shooter/step_2.html">2. Controlling the player and adding some graphics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/space_shooter/step_3.html">3. Adding animations and depth</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/space_shooter/step_4.html">4. Adding Bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/space_shooter/step_5.html">5. Adding Enemies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../tutorials/space_shooter/step_6.html">6. Enemy and Bullet collisions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../development/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/documentation.html">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/style_guide.html">Style Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../development/testing_guide.html">Tests Guide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../resources/resources.html">Resources</a><ul>
<li class="toctree-l2"><a class="reference external" href="https://pub.dev/documentation/flame/latest/">Flame API</a></li>
<li class="toctree-l2"><a class="reference external" href="https://examples.flame-engine.org/#/">Flame Examples</a></li>
</ul>
</li>
</ul>

    </div>
  </div>
</div>

<div class="main-area">
  <div class="document-wrapper">
    <div class="warning hidden" id="version-warning">
      <p><strong>Warning:</strong> you are currently viewing the docs for an older
      version <span class="version"></span> of Flame.</p>
      <p>Please <a href="/">click here</a> to go see the documentation for the latest
      released version.</p>
    </div>
    <div class="document" role="main">
      
  <section class="tex2jax_ignore mathjax_ignore" id="collision-detection">
<h1>Collision Detection<a class="headerlink" href="#collision-detection" title="Link to this heading">¶</a></h1>
<p>Collision detection is needed in most games to detect and act upon two components intersecting each
other. For example an arrow hitting an enemy or the player picking up a coin.</p>
<p>In most collision detection systems you use something called hitboxes to create more precise
bounding boxes of your components. In Flame the hitboxes are areas of the component that can react
to collisions (and make <a class="reference internal" href="inputs/gesture_input.html#gesturehitboxes"><span class="std std-ref">gesture input</span></a>) more accurate.</p>
<p>The collision detection system supports three different types of shapes that you can build hitboxes
from, these shapes are Polygon, Rectangle and Circle. Multiple hitbox can be added
to a component to form the area which can be used to either detect collisions
or whether it contains a point or not,
the latter is very useful for accurate gesture detection. The collision detection does not handle
what should happen when two hitboxes collide, so it is up to the user to implement what will happen
when for example two <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code>s have intersecting hitboxes.</p>
<p>Do note that the built-in collision detection system does not take collisions between two hitboxes
that overshoot each other into account, this could happen when they either move very fast or
<code class="docutils literal notranslate"><span class="pre">update</span></code> being called with a large delta time (for example if your app is not in the foreground).
This behavior is called tunneling, if you want to read more about it.</p>
<p>Also note that the collision detection system has a limitation that makes it not work properly if
you have certain types of combinations of flips and scales of the ancestors of the hitboxes.</p>
<section id="mixins">
<h2>Mixins<a class="headerlink" href="#mixins" title="Link to this heading">¶</a></h2>
<section id="hascollisiondetection">
<h3>HasCollisionDetection<a class="headerlink" href="#hascollisiondetection" title="Link to this heading">¶</a></h3>
<p>If you want to use collision detection in your game you have to add the <code class="docutils literal notranslate"><span class="pre">HasCollisionDetection</span></code>
mixin to your game so that it can keep track of the components that can collide.</p>
<p>Example:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now when you add <code class="docutils literal notranslate"><span class="pre">ShapeHitbox</span></code>s to components that are then added to the game, they will
automatically be checked for collisions.</p>
<p>You can also add <code class="docutils literal notranslate"><span class="pre">HasCollisionDetection</span></code> directly to another <code class="docutils literal notranslate"><span class="pre">Component</span></code> instead
of the <code class="docutils literal notranslate"><span class="pre">FlameGame</span></code>,
for example to the <code class="docutils literal notranslate"><span class="pre">World</span></code> that is used for the <code class="docutils literal notranslate"><span class="pre">CameraComponent</span></code>.
If that is done, hitboxes that are added in that component’s tree will only be compared to other
hitboxes in that subtree, which makes it possible to have several worlds with collision detection
within one <code class="docutils literal notranslate"><span class="pre">FlameGame</span></code>.</p>
<p>Example:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">CollisionDetectionWorld</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">World</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Hitboxes will only be connected to one collision detection system and that is
the closest parent that has the <code class="docutils literal notranslate"><span class="pre">HasCollisionDetection</span></code> mixin.</p>
</div>
</section>
<section id="collisioncallbacks">
<h3>CollisionCallbacks<a class="headerlink" href="#collisioncallbacks" title="Link to this heading">¶</a></h3>
<p>To react to a collision you should add the <code class="docutils literal notranslate"><span class="pre">CollisionCallbacks</span></code> mixin to your component.
Example:</p>
<div class="flutter-app-infobox docutils container">
<iframe class="flutter-app-iframe" src="/main/_static/apps/flame-examples/index.html?collision_detection" style="width: 180px; height: 160px"></iframe><div class="flutter-app-code docutils container" id="flame-examples-source-collision_detection">
<div class="filename docutils container">
collision_detection.dart</div>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:doc_flame_examples/ember.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 2</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/collisions.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 3</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/components.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/effects.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 5</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/game.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 6</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flutter/material.dart&#39;</span><span class="w"> </span><span class="k">hide</span><span class="w"> </span><span class="n">Image</span><span class="p">;</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="kd">class</span><span class="w"> </span><span class="nc">CollisionDetectionGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">10</span><span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">emberPlayer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EmberPlayer</span><span class="p">(</span>
<span class="linenos">12</span><span class="w">      </span><span class="nl">position:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">20</span><span class="p">),</span>
<span class="linenos">13</span><span class="w">      </span><span class="nl">size:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="m">40</span><span class="p">),</span>
<span class="linenos">14</span><span class="w">      </span><span class="nl">onTap:</span><span class="w"> </span><span class="p">(</span><span class="n">emberPlayer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">15</span><span class="w">        </span><span class="n">emberPlayer</span><span class="p">.</span><span class="n">add</span><span class="p">(</span>
<span class="linenos">16</span><span class="w">          </span><span class="n">MoveEffect</span><span class="p">.</span><span class="n">to</span><span class="p">(</span>
<span class="linenos">17</span><span class="w">            </span><span class="n">Vector2</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">40</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">20</span><span class="p">),</span>
<span class="linenos">18</span><span class="w">            </span><span class="n">EffectController</span><span class="p">(</span>
<span class="linenos">19</span><span class="w">              </span><span class="nl">duration:</span><span class="w"> </span><span class="m">5</span><span class="p">,</span>
<span class="linenos">20</span><span class="w">              </span><span class="nl">reverseDuration:</span><span class="w"> </span><span class="m">5</span><span class="p">,</span>
<span class="linenos">21</span><span class="w">              </span><span class="nl">repeatCount:</span><span class="w"> </span><span class="m">1</span><span class="p">,</span>
<span class="linenos">22</span><span class="w">              </span><span class="nl">curve:</span><span class="w"> </span><span class="n">Curves</span><span class="p">.</span><span class="n">easeOut</span><span class="p">,</span>
<span class="linenos">23</span><span class="w">            </span><span class="p">),</span>
<span class="linenos">24</span><span class="w">          </span><span class="p">),</span>
<span class="linenos">25</span><span class="w">        </span><span class="p">);</span>
<span class="linenos">26</span><span class="w">      </span><span class="p">},</span>
<span class="linenos">27</span><span class="w">    </span><span class="p">);</span>
<span class="linenos">28</span><span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">emberPlayer</span><span class="p">);</span>
<span class="linenos">29</span><span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">RectangleCollidable</span><span class="p">(</span><span class="n">canvasSize</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">));</span>
<span class="linenos">30</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">31</span><span class="p">}</span>
<span class="linenos">32</span>
<span class="linenos">33</span><span class="kd">class</span><span class="w"> </span><span class="nc">RectangleCollidable</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">CollisionCallbacks</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">34</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">_collisionStartColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Colors</span><span class="p">.</span><span class="n">amber</span><span class="p">;</span>
<span class="linenos">35</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">_defaultColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Colors</span><span class="p">.</span><span class="n">cyan</span><span class="p">;</span>
<span class="linenos">36</span><span class="w">  </span><span class="kd">late</span><span class="w"> </span><span class="n">ShapeHitbox</span><span class="w"> </span><span class="n">hitbox</span><span class="p">;</span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="w">  </span><span class="n">RectangleCollidable</span><span class="p">(</span><span class="n">Vector2</span><span class="w"> </span><span class="n">position</span><span class="p">)</span>
<span class="linenos">39</span><span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="k">super</span><span class="p">(</span>
<span class="linenos">40</span><span class="w">          </span><span class="nl">position:</span><span class="w"> </span><span class="n">position</span><span class="p">,</span>
<span class="linenos">41</span><span class="w">          </span><span class="nl">size:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">.</span><span class="n">all</span><span class="p">(</span><span class="m">50</span><span class="p">),</span>
<span class="linenos">42</span><span class="w">          </span><span class="nl">anchor:</span><span class="w"> </span><span class="n">Anchor</span><span class="p">.</span><span class="n">center</span><span class="p">,</span>
<span class="linenos">43</span><span class="w">        </span><span class="p">);</span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">46</span><span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">47</span><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">defaultPaint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()</span>
<span class="linenos">48</span><span class="w">      </span><span class="p">..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_defaultColor</span>
<span class="linenos">49</span><span class="w">      </span><span class="p">..</span><span class="n">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span><span class="p">;</span>
<span class="linenos">50</span><span class="w">    </span><span class="n">hitbox</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RectangleHitbox</span><span class="p">()</span>
<span class="linenos">51</span><span class="w">      </span><span class="p">..</span><span class="n">paint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">defaultPaint</span>
<span class="linenos">52</span><span class="w">      </span><span class="p">..</span><span class="n">renderShape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="linenos">53</span><span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">hitbox</span><span class="p">);</span>
<span class="linenos">54</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">55</span>
<span class="linenos">56</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">57</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onCollisionStart</span><span class="p">(</span>
<span class="linenos">58</span><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Vector2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intersectionPoints</span><span class="p">,</span>
<span class="linenos">59</span><span class="w">    </span><span class="n">PositionComponent</span><span class="w"> </span><span class="n">other</span><span class="p">,</span>
<span class="linenos">60</span><span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">61</span><span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">onCollisionStart</span><span class="p">(</span><span class="n">intersectionPoints</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="linenos">62</span><span class="w">    </span><span class="n">hitbox</span><span class="p">.</span><span class="n">paint</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_collisionStartColor</span><span class="p">;</span>
<span class="linenos">63</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">64</span>
<span class="linenos">65</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">66</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onCollisionEnd</span><span class="p">(</span><span class="n">PositionComponent</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">67</span><span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">onCollisionEnd</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="linenos">68</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isColliding</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">69</span><span class="w">      </span><span class="n">hitbox</span><span class="p">.</span><span class="n">paint</span><span class="p">.</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_defaultColor</span><span class="p">;</span>
<span class="linenos">70</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">71</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">72</span><span class="p">}</span>
</pre></div>
</div>
</div>
<button class="flutter-app-button code" onclick="open_code_listings(&quot;flame-examples-source-collision_detection&quot;)">Code</button></div>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyCollidable</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">CollisionCallbacks</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onCollision</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Vector2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">ScreenHitbox</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">//...</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">YourOtherComponent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">//...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onCollisionEnd</span><span class="p">(</span><span class="n">PositionComponent</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">ScreenHitbox</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">//...</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">YourOtherComponent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">//...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example we use Dart’s <code class="docutils literal notranslate"><span class="pre">is</span></code> keyword to check what kind of component we collided with.
The set of points is where the edges of the hitboxes intersect.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">onCollision</span></code> method will be called on both <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code>s if they have both
implemented the <code class="docutils literal notranslate"><span class="pre">onCollision</span></code> method, and also on both hitboxes. The same goes for the
<code class="docutils literal notranslate"><span class="pre">onCollisionStart</span></code> and <code class="docutils literal notranslate"><span class="pre">onCollisionEnd</span></code> methods, which are called when two components and hitboxes
starts or stops colliding with each other.</p>
<p>When a <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code> (and hitbox) starts to collide with another <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code>
both <code class="docutils literal notranslate"><span class="pre">onCollisionStart</span></code> and <code class="docutils literal notranslate"><span class="pre">onCollision</span></code> are called, so if you don’t need to do something specific
when a collision starts you only need to override <code class="docutils literal notranslate"><span class="pre">onCollision</span></code>, and vice versa.</p>
<p>If you want to check collisions with the screen edges, as we do in the example above, you can use
the predefined <a class="reference internal" href="#screenhitbox">ScreenHitbox</a> class.</p>
<p>By default all hitboxes are hollow, this means that one hitbox can be fully enclosed by another
hitbox without triggering a collision. If you want to set your hitboxes to be solid you can set
<code class="docutils literal notranslate"><span class="pre">isSolid</span> <span class="pre">=</span> <span class="pre">true</span></code>. A hollow hitbox inside of a solid hitbox will trigger a collision, but not the
other way around. If there are no intersections with the edges on a solid hitbox the center
position is instead returned.</p>
</section>
<section id="collision-order">
<h3>Collision order<a class="headerlink" href="#collision-order" title="Link to this heading">¶</a></h3>
<p>If a <code class="docutils literal notranslate"><span class="pre">Hitbox</span></code> collides with more than one other <code class="docutils literal notranslate"><span class="pre">Hitbox</span></code> within a given time step, then
the <code class="docutils literal notranslate"><span class="pre">onCollision</span></code> callbacks will be called in an essentially random order. In some cases this can
be a problem, such as in a bouncing ball game where the trajectory of the ball can differ depending
on which other object was hit first. To help resolve this the <code class="docutils literal notranslate"><span class="pre">collisionsCompletedNotifier</span></code>
listener can be used - this triggers at the end of the collision detection process.</p>
<p>An example of how this might be used is to add a local variable in your <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code> to save
the other components with which it’s colliding:
<code class="docutils literal notranslate"><span class="pre">List&lt;PositionComponent&gt;</span> <span class="pre">collisionComponents</span> <span class="pre">=</span> <span class="pre">[];</span></code>. The <code class="docutils literal notranslate"><span class="pre">onCollision</span></code> callback is then used to
save all the other <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code>s to this list:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="nd">@override</span>
<span class="kt">void</span><span class="w"> </span><span class="n">onCollision</span><span class="p">(</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Vector2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intersectionPoints</span><span class="p">,</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">collisionComponents</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="w">  </span><span class="k">super</span><span class="p">.</span><span class="n">onCollision</span><span class="p">(</span><span class="n">intersectionPoints</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, one adds a listener to the <code class="docutils literal notranslate"><span class="pre">onLoad</span></code> method of the <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code> to call a function
which will resolve how the collisions should be dealt with:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">game</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">collisionDetection</span>
<span class="w">    </span><span class="p">.</span><span class="n">collisionsCompletedNotifier</span>
<span class="w">    </span><span class="p">.</span><span class="n">addListener</span><span class="p">(()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">resolveCollisions</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The list <code class="docutils literal notranslate"><span class="pre">collisionComponents</span></code> would need to be cleared in each call to <code class="docutils literal notranslate"><span class="pre">update</span></code>.</p>
</section>
</section>
<section id="shapehitbox">
<h2>ShapeHitbox<a class="headerlink" href="#shapehitbox" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">ShapeHitbox</span></code>s are normal components, so you add them to the component that you want to add
hitboxes to just like any other component:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">RectangleHitbox</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you don’t add any arguments to the hitbox, like above, the hitbox will try to fill its parent as
much as possible. Except for having the hitboxes trying to fill their parents,
there are two ways to
initiate hitboxes and it is with the normal constructor where you define the hitbox by itself, with
a size and a position etc. The other way is to use the <code class="docutils literal notranslate"><span class="pre">relative</span></code> constructor which defines the
hitbox in relation to the size of its intended parent.</p>
<p>In some specific cases you might want to handle collisions only between hitboxes, without
propagating <code class="docutils literal notranslate"><span class="pre">onCollision*</span></code> events to the hitbox’s parent component. For example, a vehicle could
have a body hitbox to control collisions and side hitboxes to check the possibility to turn left
or right.
So, colliding with a body hitbox means colliding with the component itself, whereas colliding with
a side hitbox does not mean a real collision and should not be propagated to hitbox’s parent.
For this case you can set <code class="docutils literal notranslate"><span class="pre">triggersParentCollision</span></code> variable to <code class="docutils literal notranslate"><span class="pre">false</span></code>:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyComponent</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="kd">late</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">MySpecialHitbox</span><span class="w"> </span><span class="n">utilityHitbox</span><span class="p">;</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">utilityHitbox</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MySpecialHitbox</span><span class="p">();</span>
<span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">utilityHitbox</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">utilityHitbox</span><span class="p">.</span><span class="n">isColliding</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// do some specific things if hitbox is colliding</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="c1">// component&#39;s onCollision* functions, ignoring MySpecialHitbox collisions.</span>
<span class="p">}</span>

<span class="kd">class</span><span class="w"> </span><span class="nc">MySpecialHitbox</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">RectangleHitbox</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MySpecialHitbox</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">triggersParentCollision</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="c1">// hitbox specific onCollision* functions</span>

<span class="p">}</span>
</pre></div>
</div>
<p>You can read more about how the different shapes are defined in the
<a class="reference internal" href="components.html#shapecomponents"><span class="std std-ref">ShapeComponents</span></a> section.</p>
<p>Remember that you can add as many <code class="docutils literal notranslate"><span class="pre">ShapeHitbox</span></code>s as you want to your <code class="docutils literal notranslate"><span class="pre">PositionComponent</span></code> to make up
more complex areas. For example a snowman with a hat could be represented by three <code class="docutils literal notranslate"><span class="pre">CircleHitbox</span></code>s
and two <code class="docutils literal notranslate"><span class="pre">RectangleHitbox</span></code>s as its hat.</p>
<p>A hitbox can be used either for collision detection or for making gesture detection more accurate
on top of components, see more regarding the latter in the section about the
<a class="reference internal" href="inputs/gesture_input.html#gesturehitboxes"><span class="std std-ref">GestureHitboxes</span></a> mixin.</p>
<section id="collisiontype">
<h3>CollisionType<a class="headerlink" href="#collisiontype" title="Link to this heading">¶</a></h3>
<p>The hitboxes have a field called <code class="docutils literal notranslate"><span class="pre">collisionType</span></code> which defines when a hitbox should collide with
another. Usually you want to set as many hitboxes as possible to <code class="docutils literal notranslate"><span class="pre">CollisionType.passive</span></code> to make
the collision detection more performant. By default the <code class="docutils literal notranslate"><span class="pre">CollisionType</span></code> is <code class="docutils literal notranslate"><span class="pre">active</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">CollisionType</span></code> enum contains the following values:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">active</span></code> collides with other <code class="docutils literal notranslate"><span class="pre">Hitbox</span></code>es of type active or passive</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">passive</span></code> collides with other <code class="docutils literal notranslate"><span class="pre">Hitbox</span></code>es of type active</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">inactive</span></code> will not collide with any other <code class="docutils literal notranslate"><span class="pre">Hitbox</span></code>es</p></li>
</ul>
<p>So if you have hitboxes that you don’t need to check collisions against each other you can mark
them as passive by setting <code class="docutils literal notranslate"><span class="pre">collisionType:</span> <span class="pre">CollisionType.passive</span></code> in the constructor,
this could for example be ground components or maybe your enemies don’t need
to check collisions between each other, then they could be marked as <code class="docutils literal notranslate"><span class="pre">passive</span></code> too.</p>
<p>Imagine a game where there are a lot of bullets, that can’t collide with each other, flying towards
the player, then the player would be set to <code class="docutils literal notranslate"><span class="pre">CollisionType.active</span></code> and the bullets would be set to
<code class="docutils literal notranslate"><span class="pre">CollisionType.passive</span></code>.</p>
<p>Then we have the <code class="docutils literal notranslate"><span class="pre">inactive</span></code> type which simply doesn’t get checked at all
in the collision detection.
This could be used for example if you have components outside of the screen that you don’t care
about at the moment but that might later come back in to view so they are not completely removed
from the game.</p>
<p>These are just examples of how you could use these types, there will be a lot more use cases for
them so don’t doubt to use them even if your use case isn’t listed here.</p>
</section>
<section id="polygonhitbox">
<h3>PolygonHitbox<a class="headerlink" href="#polygonhitbox" title="Link to this heading">¶</a></h3>
<p>It should be noted that if you want to use collision detection or <code class="docutils literal notranslate"><span class="pre">containsPoint</span></code> on the <code class="docutils literal notranslate"><span class="pre">Polygon</span></code>,
the polygon needs to be convex. So always use convex polygons or you will most likely run into
problems if you don’t really know what you are doing.</p>
<p>The other hitbox shapes don’t have any mandatory constructor, that is because they can have a
default calculated from the size of the collidable that they are attached to, but since a
polygon can be made in an infinite number of ways inside of a bounding box you have to add the
definition in the constructor for this shape.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PolygonHitbox</span></code> has the same constructors as the <a class="reference internal" href="components.html#polygoncomponent"><span class="std std-ref">PolygonComponent</span></a>, see that
section for documentation regarding those.</p>
</section>
<section id="rectanglehitbox">
<h3>RectangleHitbox<a class="headerlink" href="#rectanglehitbox" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">RectangleHitbox</span></code> has the same constructors as the <a class="reference internal" href="components.html#rectanglecomponent"><span class="std std-ref">RectangleComponent</span></a>, see
that section for documentation regarding those.</p>
</section>
<section id="circlehitbox">
<h3>CircleHitbox<a class="headerlink" href="#circlehitbox" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">CircleHitbox</span></code> has the same constructors as the <a class="reference internal" href="components.html#circlecomponent"><span class="std std-ref">CircleComponent</span></a>, see that
section for documentation regarding those.</p>
</section>
</section>
<section id="screenhitbox">
<h2>ScreenHitbox<a class="headerlink" href="#screenhitbox" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ScreenHitbox</span></code> is a component which represents the edges of your viewport/screen. If you add a
<code class="docutils literal notranslate"><span class="pre">ScreenHitbox</span></code> to your game your other components with hitboxes will be notified when they
collide with the edges. It doesn’t take any arguments, it only depends on the <code class="docutils literal notranslate"><span class="pre">size</span></code> of the game
that it is added to. To add it you can just do <code class="docutils literal notranslate"><span class="pre">add(ScreenHitbox())</span></code> in your game, if you don’t
want the <code class="docutils literal notranslate"><span class="pre">ScreenHitbox</span></code> itself to be notified when something collides with it. Since
<code class="docutils literal notranslate"><span class="pre">ScreenHitbox</span></code> has the <code class="docutils literal notranslate"><span class="pre">CollisionCallbacks</span></code> mixin you can add your own <code class="docutils literal notranslate"><span class="pre">onCollisionCallback</span></code>,
<code class="docutils literal notranslate"><span class="pre">onStartCollisionCallback</span></code> and <code class="docutils literal notranslate"><span class="pre">onEndCollisionCallback</span></code> functions to that object if needed.</p>
</section>
<section id="compositehitbox">
<h2>CompositeHitbox<a class="headerlink" href="#compositehitbox" title="Link to this heading">¶</a></h2>
<p>In the <code class="docutils literal notranslate"><span class="pre">CompositeHitbox</span></code> you can add multiple hitboxes so that
they emulate being one joined hitbox.</p>
<p>If you want to form a hat for example you might want
to use two <a class="reference internal" href="#rectanglehitbox"><span class="std std-ref">RectangleHitbox</span></a>s to follow that
hat’s edges properly, then you can add those hitboxes to an instance of this class and react to
collisions to the whole hat, instead of for just each hitbox separately.</p>
</section>
<section id="broad-phase">
<h2>Broad phase<a class="headerlink" href="#broad-phase" title="Link to this heading">¶</a></h2>
<p>If your game field isn’t huge and does not have a lot of collidable components - you don’t have to
worry about the broad phase system that is used, so if the standard implementation is performant
enough for you, you probably don’t have to read this section.</p>
<p>A broad phase is the first step of collision detection where potential collisions are calculated.
Calculating these potential collisions is faster than to checking the intersections exactly,
and it removes the need to check all hitboxes against each other and
therefore avoiding O(n²).</p>
<p>The broad phase produces a set of potential collisions (a set of
<code class="docutils literal notranslate"><span class="pre">CollisionProspect</span></code>s). This set is then used to check the exact intersections between
hitboxes (sometimes called “narrow phase”).</p>
<p>By default, Flame’s collision detection is using a sweep and prune broadphase step. If your game
requires another type of broadphase you can write your own broadphase by extending <code class="docutils literal notranslate"><span class="pre">Broadphase</span></code> and
manually setting the collision detection system that should be used.</p>
<p>For example, if you have implemented a broadphase built on a magic algorithm
instead of the standard sweep and prune, then you would do the following:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyGame</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">super</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">collisionDetection</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">StandardCollisionDetection</span><span class="p">(</span><span class="nl">broadphase:</span><span class="w"> </span><span class="n">MagicAlgorithmBroadphase</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="quad-tree-broad-phase">
<h2>Quad Tree broad phase<a class="headerlink" href="#quad-tree-broad-phase" title="Link to this heading">¶</a></h2>
<p>If your game field is large and the game contains a lot of collidable
components (more than a hundred), standard sweep and prune can
become inefficient. If it does, you can try to use the quad tree broad phase.</p>
<p>To do this, add the <code class="docutils literal notranslate"><span class="pre">HasQuadTreeCollisionDetection</span></code> mixin to your game instead of
<code class="docutils literal notranslate"><span class="pre">HasCollisionDetection</span></code> and call the <code class="docutils literal notranslate"><span class="pre">initializeCollisionDetection</span></code> function on game load:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasQuadTreeCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">initializeCollisionDetection</span><span class="p">(</span>
<span class="w">      </span><span class="nl">mapDimensions:</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Rect</span><span class="p">.</span><span class="n">fromLTWH</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">mapWidth</span><span class="p">,</span><span class="w"> </span><span class="n">mapHeight</span><span class="p">),</span>
<span class="w">      </span><span class="nl">minimumDistance:</span><span class="w"> </span><span class="m">10</span><span class="p">,</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When calling <code class="docutils literal notranslate"><span class="pre">initializeCollisionDetection</span></code> you should pass it the correct map dimensions, to make
the quad tree algorithm to work properly. There are also additional parameters to make the system
more efficient:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">minimumDistance</span></code>: minimum distance between objects to consider them as possibly colliding.
If <code class="docutils literal notranslate"><span class="pre">null</span></code> - the check is disabled, it is default behavior</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxObjects</span></code>: maximum objects count in one quadrant. Default to 25.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxDepth</span></code>: maximum nesting levels inside quadrant. Default to 10</p></li>
</ul>
<p>If you use the quad tree system, you can make it even more efficient by implementing the
<code class="docutils literal notranslate"><span class="pre">onComponentTypeCheck</span></code> function of the <code class="docutils literal notranslate"><span class="pre">CollisionCallbacks</span></code> mixin in your components.
It is useful if you need to prevent collisions of items of different types.
The result of the calculation is cached so
you should not check any dynamic parameters here, the function is intended to be used as a pure
type checker:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">Bullet</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PositionComponent</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">CollisionCallbacks</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">onComponentTypeCheck</span><span class="p">(</span><span class="n">PositionComponent</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">Player</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">Water</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// do NOT collide with Player or Water</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Just return true if you&#39;re not interested in the parent&#39;s type check result.</span>
<span class="w">    </span><span class="c1">// Or call super and you will be able to override the result with the parent&#39;s</span>
<span class="w">    </span><span class="c1">// result.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">super</span><span class="p">.</span><span class="n">onComponentTypeCheck</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onCollisionStart</span><span class="p">(</span>
<span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Vector2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">intersectionPoints</span><span class="p">,</span>
<span class="w">    </span><span class="n">PositionComponent</span><span class="w"> </span><span class="n">other</span><span class="p">,</span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Removes the component when it comes in contact with a Brick.</span>
<span class="w">    </span><span class="c1">// Neither Player nor Water would be passed to this function</span>
<span class="w">    </span><span class="c1">// because these classes are filtered out by [onComponentTypeCheck]</span>
<span class="w">    </span><span class="c1">// in an earlier stage.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">Brick</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">removeFromParent</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">onCollisionStart</span><span class="p">(</span><span class="n">intersectionPoints</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After intensive gameplay a map could become over-clusterized with a lot of empty quadrants.
Run <code class="docutils literal notranslate"><span class="pre">QuadTree.optimize()</span></code> to perform a cleanup of empty quadrants:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">QuadTreeExample</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span>
<span class="w">        </span><span class="kd">with</span><span class="w"> </span><span class="n">HasQuadTreeCollisionDetection</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">/// A function called when intensive gameplay session is over</span>
<span class="w">  </span><span class="c1">/// It also might be scheduled, but no need to run it on every update.</span>
<span class="w">  </span><span class="c1">/// Use right interval depending on your game circumstances</span>
<span class="w">  </span><span class="n">onGameIdle</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">(</span><span class="n">collisionDetection</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">QuadTreeCollisionDetection</span><span class="p">)</span>
<span class="w">            </span><span class="p">.</span><span class="n">quadBroadphase</span>
<span class="w">            </span><span class="p">.</span><span class="n">tree</span>
<span class="w">            </span><span class="p">.</span><span class="n">optimize</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Always experiment with different collision detection approaches
and check how they perform on your game.
It is not unheard of that <code class="docutils literal notranslate"><span class="pre">QuadTreeBroadphase</span></code> is significantly
<em>slower</em> than the default.
Don’t assume that the more sophisticated approach is always faster.</p>
</div>
</section>
<section id="ray-casting-and-ray-tracing">
<h2>Ray casting and Ray tracing<a class="headerlink" href="#ray-casting-and-ray-tracing" title="Link to this heading">¶</a></h2>
<p>Ray casting and ray tracing are methods for sending out rays from a point in your game and being
able to see what these rays collide with and how they reflect after hitting something.</p>
<p>For all of the following methods, if there are any hitboxes that you wish to ignore,
you can add the <code class="docutils literal notranslate"><span class="pre">ignoreHitboxes</span></code> argument which is a list of the hitboxes
that you wish to disregard for the call.
This can be quite useful for example if you are casting rays from within a hitbox,
which could be on your player or NPC;
or if you don’t want a ray to bounce off a <code class="docutils literal notranslate"><span class="pre">ScreenHitbox</span></code>.</p>
<section id="ray-casting">
<h3>Ray casting<a class="headerlink" href="#ray-casting" title="Link to this heading">¶</a></h3>
<p>Ray casting is the operation of casting out one or more rays from a point and see if they hit
anything, in Flame’s case, hitboxes.</p>
<p>We provide two methods for doing so, <code class="docutils literal notranslate"><span class="pre">raycast</span></code> and <code class="docutils literal notranslate"><span class="pre">raycastAll</span></code>. The first one just casts out
a single ray and gets back a result with information about what and where the ray hit, and some
extra information like the distance, the normal and the reflection ray.
The second one, <code class="docutils literal notranslate"><span class="pre">raycastAll</span></code>,
works similarly but sends out multiple rays uniformly around the origin, or within an angle
centered at the origin.</p>
<p>By default, <code class="docutils literal notranslate"><span class="pre">raycast</span></code> and <code class="docutils literal notranslate"><span class="pre">raycastAll</span></code> scan for the nearest hit irrespective of
how far it lies from the ray origin.
But in some use cases, it might be interesting to find hits only within a certain
range. For such cases, an optional <code class="docutils literal notranslate"><span class="pre">maxDistance</span></code> can be provided.</p>
<p>To use the ray casting functionality you have to have the <code class="docutils literal notranslate"><span class="pre">HasCollisionDetection</span></code> mixin on your
game. After you have added that you can call <code class="docutils literal notranslate"><span class="pre">collisionDetection.raycast(...)</span></code> on your game class.</p>
<p>Example:</p>
<div class="flutter-app-infobox docutils container">
<iframe class="flutter-app-iframe" src="/main/_static/apps/flame-examples/index.html?ray_cast" style="width: 180px; height: 160px"></iframe><div class="flutter-app-code docutils container" id="flame-examples-source-ray_cast">
<div class="filename docutils container">
ray_cast.dart</div>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/collisions.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 2</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/components.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 3</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/game.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/geometry.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 5</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/palette.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 6</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flutter/material.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="kd">class</span><span class="w"> </span><span class="nc">RayCastExample</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">20</span><span class="p">,</span><span class="w"> </span><span class="m">20</span><span class="p">);</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">60</span><span class="p">;</span>
<span class="linenos">14</span><span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="kd">get</span><span class="w"> </span><span class="n">resetPosition</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">-</span><span class="n">canvasSize</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">  </span><span class="n">Paint</span><span class="w"> </span><span class="n">paint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Colors</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">withOpacity</span><span class="p">(</span><span class="m">0.6</span><span class="p">);</span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="w">  </span><span class="n">RaycastResult</span><span class="o">&lt;</span><span class="n">ShapeHitbox</span><span class="o">&gt;?</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">21</span><span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">22</span><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">paint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BasicPalette</span><span class="p">.</span><span class="n">gray</span><span class="p">.</span><span class="n">paint</span><span class="p">()</span>
<span class="linenos">23</span><span class="w">      </span><span class="p">..</span><span class="n">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span>
<span class="linenos">24</span><span class="w">      </span><span class="p">..</span><span class="n">strokeWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2.0</span><span class="p">;</span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="n">ScreenHitbox</span><span class="p">());</span>
<span class="linenos">27</span>
<span class="linenos">28</span><span class="w">    </span><span class="n">add</span><span class="p">(</span>
<span class="linenos">29</span><span class="w">      </span><span class="n">CircleComponent</span><span class="p">(</span>
<span class="linenos">30</span><span class="w">        </span><span class="nl">position:</span><span class="w"> </span><span class="n">canvasSize</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">,</span>
<span class="linenos">31</span><span class="w">        </span><span class="nl">radius:</span><span class="w"> </span><span class="m">30</span><span class="p">,</span>
<span class="linenos">32</span><span class="w">        </span><span class="nl">paint:</span><span class="w"> </span><span class="n">paint</span><span class="p">,</span>
<span class="linenos">33</span><span class="w">        </span><span class="nl">children:</span><span class="w"> </span><span class="p">[</span><span class="n">CircleHitbox</span><span class="p">()],</span>
<span class="linenos">34</span><span class="w">      </span><span class="p">),</span>
<span class="linenos">35</span><span class="w">    </span><span class="p">);</span>
<span class="linenos">36</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">39</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">40</span><span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="linenos">41</span><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ray2</span><span class="p">(</span>
<span class="linenos">42</span><span class="w">      </span><span class="nl">origin:</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span>
<span class="linenos">43</span><span class="w">      </span><span class="nl">direction:</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span>
<span class="linenos">44</span><span class="w">    </span><span class="p">);</span>
<span class="linenos">45</span><span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collisionDetection</span><span class="p">.</span><span class="n">raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
<span class="linenos">46</span>
<span class="linenos">47</span><span class="w">    </span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span>
<span class="linenos">48</span>
<span class="linenos">49</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">canvasSize</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">50</span><span class="w">      </span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">resetPosition</span><span class="p">;</span>
<span class="linenos">51</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">52</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">53</span>
<span class="linenos">54</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">55</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">render</span><span class="p">(</span><span class="n">Canvas</span><span class="w"> </span><span class="n">canvas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">56</span><span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">render</span><span class="p">(</span><span class="n">canvas</span><span class="p">);</span>
<span class="linenos">57</span>
<span class="linenos">58</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">result</span><span class="o">!</span><span class="p">.</span><span class="n">isActive</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">59</span><span class="w">      </span><span class="kd">final</span><span class="w"> </span><span class="n">originOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="p">.</span><span class="n">toOffset</span><span class="p">();</span>
<span class="linenos">60</span><span class="w">      </span><span class="kd">final</span><span class="w"> </span><span class="n">intersectionPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="o">!</span><span class="p">.</span><span class="n">intersectionPoint</span><span class="o">!</span><span class="p">.</span><span class="n">toOffset</span><span class="p">();</span>
<span class="linenos">61</span><span class="w">      </span><span class="n">canvas</span><span class="p">.</span><span class="n">drawLine</span><span class="p">(</span>
<span class="linenos">62</span><span class="w">        </span><span class="n">originOffset</span><span class="p">,</span>
<span class="linenos">63</span><span class="w">        </span><span class="n">intersectionPoint</span><span class="p">,</span>
<span class="linenos">64</span><span class="w">        </span><span class="n">paint</span><span class="p">,</span>
<span class="linenos">65</span><span class="w">      </span><span class="p">);</span>
<span class="linenos">66</span>
<span class="linenos">67</span><span class="w">      </span><span class="n">canvas</span><span class="p">.</span><span class="n">drawCircle</span><span class="p">(</span><span class="n">originOffset</span><span class="p">,</span><span class="w"> </span><span class="m">10</span><span class="p">,</span><span class="w"> </span><span class="n">paint</span><span class="p">);</span>
<span class="linenos">68</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">69</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">70</span><span class="p">}</span>
</pre></div>
</div>
</div>
<button class="flutter-app-button code" onclick="open_code_listings(&quot;flame-examples-source-ray_cast&quot;)">Code</button></div>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ray2</span><span class="p">(</span>
<span class="w">        </span><span class="nl">origin:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">),</span>
<span class="w">        </span><span class="nl">direction:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">),</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collisionDetection</span><span class="p">.</span><span class="n">raycast</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example one can see that the <code class="docutils literal notranslate"><span class="pre">Ray2</span></code> class is being used, this class defines a ray from an
origin position and a direction (which are both defined by <code class="docutils literal notranslate"><span class="pre">Vector2</span></code>s). This particular ray starts
from <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">100</span></code> and shoots a ray straight to the right.</p>
<p>The result from this operation will either be <code class="docutils literal notranslate"><span class="pre">null</span></code> if the ray didn’t hit anything, or a
<code class="docutils literal notranslate"><span class="pre">RaycastResult</span></code> which contains:</p>
<ul class="simple">
<li><p>Which hitbox the ray hit</p></li>
<li><p>The intersection point of the collision</p></li>
<li><p>The reflection ray, i.e. how the ray would reflect on the hitbox that it hix</p></li>
<li><p>The normal of the collision, i.e. a vector perpendicular to the face of the hitbox that it hits</p></li>
</ul>
<p>If you are concerned about performance you can pre create a <code class="docutils literal notranslate"><span class="pre">RaycastResult</span></code> object that you send in
to the method with the <code class="docutils literal notranslate"><span class="pre">out</span></code> argument, this will make it possible for the method to reuse this
object instead of creating a new one for each iteration. This can be good if you do a lot of
ray casting in your <code class="docutils literal notranslate"><span class="pre">update</span></code> methods.</p>
<section id="raycastall">
<h4>raycastAll<a class="headerlink" href="#raycastall" title="Link to this heading">¶</a></h4>
<p>Sometimes you want to send out rays in all, or a limited range, of directions from an origin. This
can have a lot of applications, for example you could calculate the field of view of a player or
enemy, or it can also be used to create light sources.</p>
<p>Example:</p>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">200</span><span class="p">,</span><span class="w"> </span><span class="m">200</span><span class="p">);</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collisionDetection</span><span class="p">.</span><span class="n">raycastAll</span><span class="p">(</span>
<span class="w">      </span><span class="n">origin</span><span class="p">,</span>
<span class="w">      </span><span class="nl">numberOfRays:</span><span class="w"> </span><span class="m">100</span><span class="p">,</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example we would send out 100 rays from (200, 200) uniformly spread in all directions.</p>
<p>If you want to limit the directions you can use the <code class="docutils literal notranslate"><span class="pre">startAngle</span></code> and the <code class="docutils literal notranslate"><span class="pre">sweepAngle</span></code> arguments.
Where the <code class="docutils literal notranslate"><span class="pre">startAngle</span></code> (counting from straight up) is where the rays will start and then the rays
will end at <code class="docutils literal notranslate"><span class="pre">startAngle</span> <span class="pre">+</span> <span class="pre">sweepAngle</span></code>.</p>
<p>If you are concerned about performance you can re-use the <code class="docutils literal notranslate"><span class="pre">RaycastResult</span></code> objects that are created
by the function by sending them in as a list with the <code class="docutils literal notranslate"><span class="pre">out</span></code> argument.</p>
</section>
</section>
<section id="ray-tracing">
<h3>Ray tracing<a class="headerlink" href="#ray-tracing" title="Link to this heading">¶</a></h3>
<p>Ray tracing is similar to ray casting, but instead of just checking what the ray hits you can
continue to trace the ray and see what its reflection ray (the ray bouncing off the hitbox) will
hit and then what that casted reflection ray’s reflection ray will hit and so on, until you decide
that you have traced the ray for long enough. If you imagine how a pool ball would bounce on a pool
table for example, that information could be retrieved with the help of ray tracing.</p>
<p>Example:</p>
<div class="flutter-app-infobox docutils container">
<iframe class="flutter-app-iframe" src="/main/_static/apps/flame-examples/index.html?ray_trace" style="width: 180px; height: 160px"></iframe><div class="flutter-app-code docutils container" id="flame-examples-source-ray_trace">
<div class="filename docutils container">
ray_trace.dart</div>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;dart:math&#39;</span><span class="p">;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/collisions.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/components.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 5</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/events.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 6</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/game.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/geometry.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flame/palette.dart&#39;</span><span class="p">;</span>
<span class="linenos"> 9</span><span class="k">import</span><span class="w"> </span><span class="s1">&#39;package:flutter/material.dart&#39;</span><span class="p">;</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="kd">class</span><span class="w"> </span><span class="nc">RayTraceExample</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span>
<span class="linenos">12</span><span class="w">    </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="p">,</span><span class="w"> </span><span class="n">TapDetector</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">13</span><span class="w">  </span><span class="n">Paint</span><span class="w"> </span><span class="n">paint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Paint</span><span class="p">()..</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Colors</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">withOpacity</span><span class="p">(</span><span class="m">0.6</span><span class="p">);</span>
<span class="linenos">14</span><span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">isClicked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w">  </span><span class="n">Vector2</span><span class="w"> </span><span class="kd">get</span><span class="w"> </span><span class="n">origin</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">canvasSize</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="w">  </span><span class="n">RaycastResult</span><span class="o">&lt;</span><span class="n">ShapeHitbox</span><span class="o">&gt;?</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="linenos">19</span>
<span class="linenos">20</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">Ray2</span><span class="w"> </span><span class="n">_ray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ray2</span><span class="p">.</span><span class="n">zero</span><span class="p">();</span>
<span class="linenos">21</span>
<span class="linenos">22</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">boxPaint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BasicPalette</span><span class="p">.</span><span class="n">gray</span><span class="p">.</span><span class="n">paint</span><span class="p">()</span>
<span class="linenos">23</span><span class="w">    </span><span class="p">..</span><span class="n">style</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PaintingStyle</span><span class="p">.</span><span class="n">stroke</span>
<span class="linenos">24</span><span class="w">    </span><span class="p">..</span><span class="n">strokeWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2.0</span><span class="p">;</span>
<span class="linenos">25</span>
<span class="linenos">26</span><span class="w">  </span><span class="kd">final</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">RaycastResult</span><span class="o">&lt;</span><span class="n">ShapeHitbox</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="linenos">27</span>
<span class="linenos">28</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">29</span><span class="w">  </span><span class="n">Future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">onLoad</span><span class="p">()</span><span class="w"> </span><span class="kd">async</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">30</span><span class="w">    </span><span class="n">add</span><span class="p">(</span>
<span class="linenos">31</span><span class="w">      </span><span class="n">CircleComponent</span><span class="p">(</span>
<span class="linenos">32</span><span class="w">        </span><span class="nl">radius:</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">,</span>
<span class="linenos">33</span><span class="w">        </span><span class="nl">paint:</span><span class="w"> </span><span class="n">boxPaint</span><span class="p">,</span>
<span class="linenos">34</span><span class="w">        </span><span class="nl">children:</span><span class="w"> </span><span class="p">[</span><span class="n">CircleHitbox</span><span class="p">()],</span>
<span class="linenos">35</span><span class="w">      </span><span class="p">),</span>
<span class="linenos">36</span><span class="w">    </span><span class="p">);</span>
<span class="linenos">37</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">38</span>
<span class="linenos">39</span><span class="w">  </span><span class="kd">var</span><span class="w"> </span><span class="n">_timePassed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.0</span><span class="p">;</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">42</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">43</span><span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="linenos">44</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isClicked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">45</span><span class="w">      </span><span class="n">_timePassed</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dt</span><span class="p">;</span>
<span class="linenos">46</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collisionDetection</span><span class="p">.</span><span class="n">raycast</span><span class="p">(</span><span class="n">_ray</span><span class="p">);</span>
<span class="linenos">49</span>
<span class="linenos">50</span><span class="w">    </span><span class="n">_ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">setFrom</span><span class="p">(</span><span class="n">origin</span><span class="p">);</span>
<span class="linenos">51</span><span class="w">    </span><span class="n">_ray</span><span class="p">.</span><span class="n">direction</span>
<span class="linenos">52</span><span class="w">      </span><span class="p">..</span><span class="n">setValues</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)</span>
<span class="linenos">53</span><span class="w">      </span><span class="p">..</span><span class="n">normalize</span><span class="p">();</span>
<span class="linenos">54</span><span class="w">    </span><span class="n">collisionDetection</span>
<span class="linenos">55</span><span class="w">        </span><span class="p">.</span><span class="n">raytrace</span><span class="p">(</span>
<span class="linenos">56</span><span class="w">          </span><span class="n">_ray</span><span class="p">,</span>
<span class="linenos">57</span><span class="w">          </span><span class="nl">maxDepth:</span><span class="w"> </span><span class="n">min</span><span class="p">((</span><span class="n">_timePassed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">8</span><span class="p">).</span><span class="n">ceil</span><span class="p">(),</span><span class="w"> </span><span class="m">1000</span><span class="p">),</span>
<span class="linenos">58</span><span class="w">          </span><span class="nl">out:</span><span class="w"> </span><span class="n">results</span><span class="p">,</span>
<span class="linenos">59</span><span class="w">        </span><span class="p">)</span>
<span class="linenos">60</span><span class="w">        </span><span class="p">.</span><span class="n">toList</span><span class="p">();</span>
<span class="linenos">61</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">62</span>
<span class="linenos">63</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">64</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">render</span><span class="p">(</span><span class="n">Canvas</span><span class="w"> </span><span class="n">canvas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">65</span><span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">render</span><span class="p">(</span><span class="n">canvas</span><span class="p">);</span>
<span class="linenos">66</span><span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="n">originOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origin</span><span class="p">.</span><span class="n">toOffset</span><span class="p">();</span>
<span class="linenos">67</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">68</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">isActive</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">69</span><span class="w">        </span><span class="k">continue</span><span class="p">;</span>
<span class="linenos">70</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">71</span><span class="w">      </span><span class="kd">final</span><span class="w"> </span><span class="n">intersectionPoint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">intersectionPoint</span><span class="o">!</span><span class="p">.</span><span class="n">toOffset</span><span class="p">();</span>
<span class="linenos">72</span><span class="w">      </span><span class="n">canvas</span><span class="p">.</span><span class="n">drawLine</span><span class="p">(</span>
<span class="linenos">73</span><span class="w">        </span><span class="n">originOffset</span><span class="p">,</span>
<span class="linenos">74</span><span class="w">        </span><span class="n">intersectionPoint</span><span class="p">,</span>
<span class="linenos">75</span><span class="w">        </span><span class="n">paint</span><span class="p">,</span>
<span class="linenos">76</span><span class="w">      </span><span class="p">);</span>
<span class="linenos">77</span><span class="w">      </span><span class="n">originOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intersectionPoint</span><span class="p">;</span>
<span class="linenos">78</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">79</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">80</span>
<span class="linenos">81</span><span class="w">  </span><span class="nd">@override</span>
<span class="linenos">82</span><span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">onTap</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">83</span><span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">onTap</span><span class="p">();</span>
<span class="linenos">84</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isClicked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">85</span><span class="w">      </span><span class="n">isClicked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="linenos">86</span><span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="linenos">87</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">88</span><span class="w">    </span><span class="n">_timePassed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="linenos">89</span><span class="w">  </span><span class="p">}</span>
<span class="linenos">90</span><span class="p">}</span>
</pre></div>
</div>
</div>
<button class="flutter-app-button code" onclick="open_code_listings(&quot;flame-examples-source-ray_trace&quot;)">Code</button></div>
<div class="highlight-dart notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nc">MyGame</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">FlameGame</span><span class="w"> </span><span class="kd">with</span><span class="w"> </span><span class="n">HasCollisionDetection</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@override</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">super</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ray2</span><span class="p">(</span>
<span class="w">        </span><span class="nl">origin:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">100</span><span class="p">),</span>
<span class="w">        </span><span class="nl">direction:</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">)..</span><span class="n">normalize</span><span class="p">()</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collisionDetection</span><span class="p">.</span><span class="n">raytrace</span><span class="p">(</span>
<span class="w">      </span><span class="n">ray</span><span class="p">,</span>
<span class="w">      </span><span class="nl">maxDepth:</span><span class="w"> </span><span class="m">100</span><span class="p">,</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">intersectionPoint</span><span class="p">.</span><span class="n">distanceTo</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">300</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above we send out a ray from (0, 100) diagonally down to the right
and we say that we want it the bounce on at most 100 hitboxes,
it doesn’t necessarily have to get 100 results since at
some point one of the reflection rays might not hit a hitbox and then the method is done.</p>
<p>The method is lazy, which means that it will only do the calculations that you ask for, so you have
to loop through the iterable that it returns to get the results, or do <code class="docutils literal notranslate"><span class="pre">toList()</span></code> to directly
calculate all the results.</p>
<p>In the for-loop it can be seen how this can be used, in that loop we check whether the current
reflection rays intersection point (where the previous ray hit the hitbox) is further away than 300
pixels from the origin of the starting ray, and if it is we don’t care about the rest
of the results (and then they don’t have to be calculated either).</p>
<p>If you are concerned about performance you can re-use the <code class="docutils literal notranslate"><span class="pre">RaycastResult</span></code> objects that are created
by the function by sending them in as a list with the <code class="docutils literal notranslate"><span class="pre">out</span></code> argument.</p>
</section>
</section>
<section id="comparison-to-forge2d">
<h2>Comparison to Forge2D<a class="headerlink" href="#comparison-to-forge2d" title="Link to this heading">¶</a></h2>
<p>If you want to have a full-blown physics engine in your game we recommend that you use
Forge2D by adding <a class="reference external" href="https://github.com/flame-engine/flame_forge2d">flame_forge2d</a> as a dependency.
But if you have a simpler use-case and just want to check for collisions of components and improve
the accuracy of gestures, Flame’s built-in collision detection will serve you very well.</p>
<p>If you have the following needs you should at least consider to use
<a class="reference external" href="https://github.com/flame-engine/forge2d">Forge2D</a>:</p>
<ul class="simple">
<li><p>Interacting realistic forces</p></li>
<li><p>Particle systems that can interact with other bodies</p></li>
<li><p>Joints between bodies</p></li>
</ul>
<p>It is a good idea to just use the Flame collision detection system if you on the other hand only
need some of the following things (since it is simpler to not involve Forge2D):</p>
<ul class="simple">
<li><p>The ability to act on some of your components colliding</p></li>
<li><p>The ability to act on your components colliding with the screen boundaries</p></li>
<li><p>Complex shapes to act as a hitbox for your component so that gestures will be more accurate</p></li>
<li><p>Hitboxes that can tell what part of a component that collided with something</p></li>
</ul>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://examples.flame-engine.org/#/Collision_Detection_Collidable_AnimationComponent">Collidable AnimationComponent</a></p></li>
<li><p><a class="reference external" href="https://examples.flame-engine.org/#/Collision_Detection_Circles">Circles</a></p></li>
<li><p><a class="reference external" href="https://examples.flame-engine.org/#/Collision_Detection_Multiple_shapes">Multiple shapes</a></p></li>
<li><p><a class="reference external" href="https://github.com/flame-engine/flame/tree/main/examples/lib/stories/collision_detection">More Examples</a></p></li>
</ul>
</section>
</section>


    </div>
    <div class="copyright">
      The content on this page is licensed under the <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0 License</a>,
      and code samples under the <a href="https://raw.githubusercontent.com/flame-engine/flame/main/LICENSE">MIT License</a>.
    </div>
    <div class="prev-next-area">
      <a class="left-prev" id="prev-link" href="platforms.html" title="previous page">
        <i class="fa fa-angle-left"></i>
        <div class="prev-next-info">
          <p class="prev-next-subtitle">Previous:</p>
          <p class="prev-next-title">Supported Platforms</p>
        </div>
      </a>
      <div class='expander'></div>
      <a class="right-next" id="next-link" href="effects.html" title="next page">
        <div class="prev-next-info">
          <p class="prev-next-subtitle">Next:</p>
          <p class="prev-next-title">Effects</p>
        </div>
        <i class="fa fa-angle-right"></i>
      </a>
    </div>
  </div>

  <div class="sidebar-right">
    
    <div class="nav-right" role="navigation" aria-label="table of contents">
      <div id='toc-local' class='list-group'>
 <div class='header'><i class='fa fa-list'></i> Contents</div>
  <a href='#mixins' class='list-group-item level-1'>Mixins</a>
  <a href='#hascollisiondetection' class='list-group-item level-2'>HasCollisionDetection</a>
  <a href='#collisioncallbacks' class='list-group-item level-2'>CollisionCallbacks</a>
  <a href='#collision-order' class='list-group-item level-2'>Collision order</a>
  <a href='#shapehitbox' class='list-group-item level-1'>ShapeHitbox</a>
  <a href='#collisiontype' class='list-group-item level-2'>CollisionType</a>
  <a href='#polygonhitbox' class='list-group-item level-2'>PolygonHitbox</a>
  <a href='#rectanglehitbox' class='list-group-item level-2'>RectangleHitbox</a>
  <a href='#circlehitbox' class='list-group-item level-2'>CircleHitbox</a>
  <a href='#screenhitbox' class='list-group-item level-1'>ScreenHitbox</a>
  <a href='#compositehitbox' class='list-group-item level-1'>CompositeHitbox</a>
  <a href='#broad-phase' class='list-group-item level-1'>Broad phase</a>
  <a href='#quad-tree-broad-phase' class='list-group-item level-1'>Quad Tree broad phase</a>
  <a href='#ray-casting-and-ray-tracing' class='list-group-item level-1'>Ray casting and Ray tracing</a>
  <a href='#ray-casting' class='list-group-item level-2'>Ray casting</a>
  <a href='#raycastall' class='list-group-item level-3'>raycastAll</a>
  <a href='#ray-tracing' class='list-group-item level-2'>Ray tracing</a>
  <a href='#comparison-to-forge2d' class='list-group-item level-1'>Comparison to Forge2D</a>
  <a href='#examples' class='list-group-item level-1'>Examples</a>
</div>

    </div>
  </div>

  <div class="expander"></div>
</div>




</body>
</html>